<!DOCTYPE html>
<html lang="en">

<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.8.0/p5.js"></script>
  <meta charset="utf-8" />
  <link href="https://fonts.googleapis.com/css2?family=Cookie&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;700&display=swap" rel="stylesheet">

  <style>
    body {
      margin: 0;
      padding: 0;
      background-image: url('./assets/background.webp');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }
    
    /* æ·»åŠ ç»“æŸæç¤ºæ ·å¼ */
    .end-note {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(180, 150, 200, 0.7);
      text-align: center;
      font-style: italic;
      font-size: 14px;
      font-family: 'Manrope', sans-serif;
      background-color: rgba(30, 30, 45, 0.7);
      padding: 8px 16px;
      border-radius: 20px;
      z-index: 1000;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <main></main>
  
  <!-- æ·»åŠ ç»“æŸæç¤º -->
  <div class="end-note">â€” End of Scene 3 â€” Continue exploring or return to main page via top-right button</div>

  <audio id="audio-shutter" src="./assets/camera-shutter.mp3" preload="auto"></audio>

  <script src="./landmarks.js"></script>
  <script>
    // æ·»åŠ å…¨å±€é”™è¯¯æ•è·
    window.onerror = function(message, source, lineno, colno, error) {
      console.error(`å…¨å±€é”™è¯¯: ${message} @ ${source}:${lineno}`);
      return true; // é˜»æ­¢é»˜è®¤é”™è¯¯æç¤º
    };
    
    let bgImg;
    let myHandLandmarker;
    let myFaceLandmarker;
    let handLandmarks;
    let faceLandmarks;
    let myCapture;
    let lastVideoTime = -1;
    // let upVideo, downVideo;  // Removed
    // let currentVideo = null;  // Removed

    const trackingConfig = {
      doAcquireHandLandmarks: true,
      doAcquireFaceLandmarks: true,
      doAcquireFaceMetrics: true,
      poseModelLiteOrFull: "lite",
      cpuOrGpuString: "GPU",
      maxNumHands: 1,
      maxNumFaces: 1,
    };

    let captureButton;
    let photoList = []
    let captureNumSlider;
    let captureCenterPos = {}
    let isHappy = false;
    let isDelete = false;
    let draggedPhoto = null;  // æ·»åŠ ä¸€ä¸ªå˜é‡æ¥è·Ÿè¸ªå½“å‰æ‹–åŠ¨çš„ç…§ç‰‡
    let wasHappy = false; // Track previous happy state for emoji trigger
    let showFaceMesh = false; // State for face mesh visibility
    let showAsciiArt = false; // State for ASCII art visibility
    let faceMeshButton, asciiArtButton; // Button objects

    // +++ Exhibition Area Variables +++
    let exhibitionArea = {};
    let nextPhotoIndex = 0;
    const photoDisplaySize = 100; // ç…§ç‰‡åœ¨å±•è§ˆåŒºæ˜¾ç¤ºçš„å°ºå¯¸
    const photoSpacing = 20;      // ç…§ç‰‡é—´è·
    const photoGridCols = 3;      // å³ä¾§å±•è§ˆå¢™çš„åˆ—æ•° (æ”¹ä¸º3åˆ—)
    const photoGridMaxRows = 5; // æœ€å¤šæ˜¾ç¤º5è¡Œï¼ŒåŸä¸º6è¡Œ
    // +++ End Exhibition Area Variables +++

    // +++ Icon Art Variables +++
    // ä¸ä½¿ç”¨å­—æ¯ï¼Œæ”¹ç”¨å›¾æ ‡å’Œç¬¦å·
    let iconChars = "â—‹â—â™¥â˜ºâ˜»â–¬â†‘â†“â†’â†âˆŸâ†”â–²â–¼" + 
                   "!'*+,-./0123456789" +
                   "â– " ;

    let cellSize = 10; // ä½¿ç”¨è¾ƒå¤§çš„å•å…ƒæ ¼ä»¥ä¾¿æ›´æ¸…æ™°åœ°æ˜¾ç¤ºå›¾æ ‡
    let lastAsciiUpdateTime = 0; // ä¸Šæ¬¡æ›´æ–°ASCIIè‰ºæœ¯çš„æ—¶é—´
    const ASCII_UPDATE_INTERVAL = 333; // ASCIIæ›´æ–°é—´éš”ä¸º333æ¯«ç§’ï¼ˆæ¯ç§’3æ¬¡ï¼‰
    let asciiCharacters = []; // å­˜å‚¨å½“å‰ASCIIå­—ç¬¦
    // +++ End Icon Art Variables +++

    // +++ Data Rain Background Variables +++
    let bgSymbols = [];
    let charPool = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W"];
    const symbolSize = 20;
    // +++ End Data Rain Background Variables +++

    // +++ Emoji Variables +++
    let happyEmojis = ['âœ¨','ğŸ¤','ğŸ«¶','ğŸ’—','ğŸ€','ğŸ«§','ğŸ§¸','ğŸ’•']; // å¼€å¿ƒemojié›†åˆ
    let cellSizeEmoji = 30; // emojiæ˜¾ç¤ºçš„å•å…ƒæ ¼å¤§å°
    let lastEmojiUpdateTime = 0; // ä¸Šæ¬¡æ›´æ–°emojiçš„æ—¶é—´
    const EMOJI_UPDATE_INTERVAL = 3000; // emojiæ›´æ–°é—´éš”ä¸º3ç§’
    let emojiPositions = []; // å­˜å‚¨å½“å‰emojiçš„ä½ç½®å’Œå­—ç¬¦
    // +++ End Emoji Variables +++

    async function preload() {
      // bgImg = loadImage("./assets/background3.png"); // Removed
      
      // åŠ è½½è§†é¢‘ - REMOVED
      // upVideo = createVideo(['./assets/up.mp4']);
      // downVideo = createVideo(['./assets/down.mp4']);
      // upVideo.hide();
      // downVideo.hide();
      
      const mediapipe_module = await import(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js"
      );

      HandLandmarker = mediapipe_module.HandLandmarker;
      FaceLandmarker = mediapipe_module.FaceLandmarker;
      FilesetResolver = mediapipe_module.FilesetResolver;

      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.7/wasm"
      );

      if (trackingConfig.doAcquireHandLandmarks) {
        myHandLandmarker = await HandLandmarker.createFromOptions(vision, {
          numHands: trackingConfig.maxNumHands,
          runningMode: "VIDEO",
          baseOptions: {
            delegate: trackingConfig.cpuOrGpuString,
            modelAssetPath:
              "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          },
        });
      }

      if (trackingConfig.doAcquireFaceLandmarks) {
        myFaceLandmarker = await FaceLandmarker.createFromOptions(vision, {
          numFaces: trackingConfig.maxNumFaces,
          runningMode: "VIDEO",
          outputFaceBlendshapes: trackingConfig.doAcquireFaceMetrics,
          baseOptions: {
            delegate: trackingConfig.cpuOrGpuString,
            modelAssetPath:
              "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
          },
        });
      }

      // +++ Initialize Data Rain +++
      textFont("Courier New"); // Ensure font is set for size calculation if needed
      textSize(symbolSize);
      
      // +++ ADD NEW LIMITED LOOP START +++
      let maxSymbols = min(floor(width / symbolSize), 40); // Limit to 40 symbols max
      let totalRainWidth = maxSymbols * symbolSize;         // Calculate total width of the rain
      let startX = (width - totalRainWidth) / 2;           // Calculate starting X for centering
      for (let i = 0; i < maxSymbols; i++) {                 // Loop up to maxSymbols
        let symbolX = startX + i * symbolSize;             // Calculate centered X for this symbol
        // bgSymbols.push(new CharSymbol(i * symbolSize, random(-100, 0))); // Remove original incorrect line
        bgSymbols.push(new CharSymbol(symbolX, random(-100, 0))); // Use centered X
      }
      // +++ ADD NEW LIMITED LOOP END +++
      
      // +++ End Initialize Data Rain +++

      // +++ Schedule Emoji Updates +++
      setInterval(updateEmojiPositions, EMOJI_UPDATE_INTERVAL);
      // +++ End Schedule Emoji Updates +++

      // è®¾ç½®è§†é¢‘åˆå§‹çŠ¶æ€ - REMOVED
      // upVideo.play();
      // downVideo.play();
      // upVideo.pause();
      // downVideo.pause();
    }

    async function predictWebcam() {
      // å¢åŠ çŠ¶æ€æ£€æŸ¥ï¼Œé˜²æ­¢åœ¨æ‘„åƒå¤´æœªå‡†å¤‡å¥½æ—¶æ‰§è¡Œ
      if (!myCapture?.elt?.currentTime) return;
      
      let startTimeMs = performance.now();
      if (lastVideoTime !== myCapture.elt.currentTime) {
        if (trackingConfig.doAcquireHandLandmarks && myHandLandmarker) {
          handLandmarks = myHandLandmarker.detectForVideo(
            myCapture.elt,
            startTimeMs
          );
        }

        if (trackingConfig.doAcquireFaceLandmarks && myFaceLandmarker) {
          faceLandmarks = myFaceLandmarker.detectForVideo(
            myCapture.elt,
            startTimeMs
          );
        }
        lastVideoTime = myCapture.elt.currentTime;
      }
    }

    function setup() {
      createCanvas(windowWidth, windowHeight, P2D);
      myCapture = createCapture(VIDEO);
      myCapture.size(400, 300);
      myCapture.hide();
      // è®¾ç½®canvasé€æ˜åº¦
      let cnv = document.querySelector('canvas');
      if (cnv) {
        cnv.style.background = 'transparent';
      }

      imageMode(CENTER);
      textAlign(CENTER, CENTER);
      textFont('Manrope'); // Set Manrope as the default font

      // Calculate viewfinder top Y for positioning UI elements above it
      let viewfinderTopY = (height / 2 - 130) - myCapture.height / 2; // Approx height / 2 - 280
      let viewfinderBottomY = captureCenterPos.y + myCapture.height / 2; // Approx height / 2 + 150

      // --- Recalculate Y positions based on top/bottom margins --- 
      let topMargin = height * 0.1;
      let bottomMargin = height * 0.1; 
      
      let buttonY = topMargin + 25; // Position button near the top
      let sliderY = height - bottomMargin - 30; // Position slider near bottom
      
      // --- REMOVE OLD/DUPLICATE Calculations ---
      // let sliderTextTargetY = viewfinderTopY - 15; 
      // let sliderY = sliderTextTargetY - 35; 
      // let buttonY = sliderY - 10 - 42; 
      // let buttonY = viewfinderBottomY + 20; 
      // let sliderY = buttonY + 42 + 10; 
      // let buttonY = sliderY - 10 - 42; 
      // let sliderY_new = height - bottomMargin - 30;
      // --- End Recalculation --- 

      captureButton = {
        x: width / 2 - 50,  // è°ƒæ•´xåæ ‡ä»¥ä¿æŒå±…ä¸­(ä¸€åŠçš„å®½åº¦)
        y: buttonY, // Use top-based Y
        w: 100,  // å®½åº¦æ”¹ä¸º100px
        h: 42
      }

      captureNumSlider = createSlider(1, 3, 1, 1);
      captureNumSlider.position(width / 2 - 100, sliderY); // Use bottom-based Y
      captureNumSlider.style('width', '200px');

      captureCenterPos = {
        x: width / 2,
        // y: height / 2 - myCapture.height + 20 // Original calculation - very high
        // y: height / 2 - 130                    // New calculation - moved down
        y: height / 2                          // Position exactly in the center
      }

      // +++ Setup Exhibition Area (Right Wall Grid) +++
      let gridWidth = photoGridCols * photoDisplaySize + (photoGridCols - 1) * photoSpacing;
      let gridStartX = width - gridWidth - 50; // å³ä¾§ç•™50pxè¾¹è·
      let gridStartY = 220; // ä»åŸæœ¬ç¬¬äºŒè¡Œçš„é«˜åº¦å¼€å§‹ (åŸä¸º100)
      exhibitionArea = {
        startX: gridStartX,
        startY: gridStartY,
        photoSize: photoDisplaySize,
        spacing: photoSpacing,
        cols: photoGridCols,
        maxRows: photoGridMaxRows // æ·»åŠ æœ€å¤§è¡Œæ•°
      };
      // +++ End Setup Exhibition Area +++

      // +++ Setup Toggle Buttons +++
      let toggleButtonW = 120; // è°ƒæ•´æŒ‰é’®å®½åº¦ï¼Œä»140pxå‡å°åˆ°120px
      let toggleButtonH = 36; // è°ƒæ•´æŒ‰é’®é«˜åº¦ï¼Œä»42pxå‡å°åˆ°36px
      let labelBottomY = 15 + 14; // Approx bottom of the labels (labelY + textSize)
      faceMeshButton = {
        x: (width / 3) / 2 - toggleButtonW / 2, // Centered in left third
        y: labelBottomY + 15, // å‘ä¸‹åç§»é€‚ä¸­ï¼Œä»20pxå‡å°åˆ°15px
        w: toggleButtonW,
        h: toggleButtonH
      };
      asciiArtButton = {
        x: (width / 3) + (width / 3) / 2 - toggleButtonW / 2, // Centered in middle third
        y: labelBottomY + 15, // å‘ä¸‹åç§»é€‚ä¸­ï¼Œä»20pxå‡å°åˆ°15px
        w: toggleButtonW,
        h: toggleButtonH
      };
      // +++ End Setup Toggle Buttons +++

      // è®¾ç½®æ–‡æœ¬å±æ€§
      // textFont('monospace'); // REMOVED - Default is now Manrope
      // textSize(cellSize); // ä½¿ç”¨iconCharsçš„å¤§å° - Moved to where ASCII is drawn
      textAlign(CENTER, CENTER);
      noStroke();

      // åˆå§‹åŒ–emojiä½ç½®æ•°ç»„
      emojiPositions = [];
      
      // åˆå§‹åŒ–ASCIIå­—ç¬¦æ•°ç»„
      asciiCharacters = [];

      // +++ Initialize Data Rain +++
      textFont("Courier New"); // Ensure font is set for size calculation if needed
      textSize(symbolSize);
      // åˆ é™¤ä»¥ä¸‹é‡å¤åˆå§‹åŒ–ä»£ç 
      // let maxSymbols = min(floor(width / symbolSize), 60); // Limit to 60 symbols max
      // for (let i = 0; i < maxSymbols; i++) { // Use the limited count
      //   bgSymbols.push(new CharSymbol(i * symbolSize, random(-100, 0)));
      // }
      // +++ End Initialize Data Rain +++

      // è®¾ç½®è§†é¢‘åˆå§‹çŠ¶æ€ - REMOVED
      // upVideo.play();
      // downVideo.play();
      // upVideo.pause();
      // downVideo.pause();
    }

    function draw() {
      // +++ Set base background color with very low opacity +++
      clear(); // æ¸…é™¤canvasè€Œä¸æ˜¯ç”¨ä¸é€æ˜èƒŒæ™¯è¦†ç›–
      background(30, 30, 50, 80); // ä½¿ç”¨é«˜é€æ˜åº¦èƒŒæ™¯ï¼Œè®©åº•å±‚å›¾ç‰‡æ›´æ˜æ˜¾
      // +++ Draw Data Rain Background Symbols +++
      drawDataBackground(); 
      // +++ End Draw Data Rain Background +++
      
      // +++ Draw Three Container Outlines +++
      push();
      stroke(150, 150, 150, 100); // Semi-transparent gray lines
      strokeWeight(1);
      noFill();
      let thirdWidth = width / 3;
      rect(0, 0, thirdWidth, height);          // Left container
      rect(thirdWidth, 0, thirdWidth, height); // Middle container
      rect(2 * thirdWidth, 0, thirdWidth, height); // Right container
      pop();
      // +++ End Draw Container Outlines +++

      // +++ Draw Section Labels +++
      push();
      
      // æ·»åŠ å…‰æ™•å’Œæ–‡æœ¬é˜´å½±æ•ˆæœ
      // ä½¿ç”¨å‰é¢å·²å®šä¹‰çš„thirdWidthå˜é‡
      let labelY = 15; // Position labels near the top
      
      // ç»˜åˆ¶æ–‡æœ¬é˜´å½±
      fill(100, 80, 150);
      textSize(18); // å¢å¤§å­—ä½“
      textStyle(BOLD);
      textAlign(CENTER, TOP);
      text("1. face format", thirdWidth / 2 + 1, labelY + 1);
      text("2. Live View & ASCII Art", thirdWidth + thirdWidth / 2 + 1, labelY + 1);
      text("3. your selfie shelf", 2 * thirdWidth + thirdWidth / 2 + 1, labelY + 1);
      
      // ç»˜åˆ¶ä¸»è¦æ–‡æœ¬
      fill(230, 220, 255); // æ›´äº®çš„æ–‡æœ¬é¢œè‰²
      textSize(18); // å¢å¤§å­—ä½“
      textStyle(BOLD);
      text("1. face format", thirdWidth / 2, labelY);
      text("2. Live View & ASCII Art", thirdWidth + thirdWidth / 2, labelY);
      text("3. your selfie shelf", 2 * thirdWidth + thirdWidth / 2, labelY);
      
      // åˆ é™¤ä¸‹åˆ’çº¿ç›¸å…³ä»£ç 
      // æ·»åŠ æ–‡å­—ä¸‹åˆ’çº¿
      // stroke(230, 220, 255); // ä¸æ–‡å­—ç›¸åŒçš„é¢œè‰²
      // strokeWeight(1);
      
      // è®¡ç®—æ¯ä¸ªæ ‡é¢˜çš„å®½åº¦å’Œä¸‹åˆ’çº¿ä½ç½®
      // let titleWidth1 = textWidth("face format");
      // let titleWidth2 = textWidth("Live View & ASCII Art");
      // let titleWidth3 = textWidth("your selfie shelf");
      
      // ç»˜åˆ¶ä¸‰ä¸ªæ ‡é¢˜çš„ä¸‹åˆ’çº¿
      // line(thirdWidth / 2 - titleWidth1/2, labelY + 22, thirdWidth / 2 + titleWidth1/2, labelY + 22);
      // line(thirdWidth + thirdWidth / 2 - titleWidth2/2, labelY + 22, thirdWidth + thirdWidth / 2 + titleWidth2/2, labelY + 22);
      // line(2 * thirdWidth + thirdWidth / 2 - titleWidth3/2, labelY + 22, 2 * thirdWidth + thirdWidth / 2 + titleWidth3/2, labelY + 22);
      
      pop();
      // +++ End Draw Section Labels ++

      // ç§»é™¤æ­¤å¤„çš„æŒ‰é’®ç»˜åˆ¶ä»£ç ï¼Œæ”¾åˆ°æœ€åç»˜åˆ¶ç¡®ä¿åœ¨æœ€ä¸Šå±‚
      // +++ Draw Toggle Buttons +++ [MOVED TO THE END OF DRAW]

      myCapture.loadPixels(); // Load pixels once per frame before processing
      
      // +++ NEW: å…ˆç»˜åˆ¶æ–‡æœ¬æ¡†ï¼Œå°†å…¶æ”¾åœ¨è§†é¢‘ä¸‹å±‚ +++
      // First draw a containing box (ç§»åŠ¨åˆ°è§†é¢‘ç»˜åˆ¶ä¹‹å‰)
      push();
      let buttonBoxWidth = width * 0.3; // ä½¿ç”¨å±å¹•å®½åº¦çš„30%
      let buttonBoxHeight = 120; // å°†é«˜åº¦è°ƒæ•´ä¸º120px
      let buttonBoxX = captureButton.x + 36 - buttonBoxWidth/2; // Center around button
      let buttonBoxY = captureButton.y - 30; // Start above button
      
      // å·¦ä¾§æ–‡æœ¬æ¡†
      let leftBoxWidth = width * 0.25; // å·¦ä¾§æ–‡æœ¬æ¡†å®½åº¦ç¨çª„
      let leftBoxX = width/6 - leftBoxWidth/2; // åœ¨å·¦ä¾§ä¸‰åˆ†ä¹‹ä¸€åŒºåŸŸå±…ä¸­
      fill(40, 40, 60, 240); // ä¸ä¸­é—´æ¡†ç›¸åŒçš„èƒŒæ™¯è‰²
      stroke(150); // ç°è‰²è¾¹æ¡†
      strokeWeight(0.75);
      rect(leftBoxX, buttonBoxY, leftBoxWidth, buttonBoxHeight, 8); // ä¸ä¸­é—´æ¡†åŒé«˜åº¦
      
      // ä¸­é—´åŒºåŸŸæ–‡æœ¬æ¡†
      // Box background with increased opacity
      fill(40, 40, 60, 240); // Darker background with more opacity
      stroke(isHappy ? color(255, 120, 170) : color(150)); // Pink outline when happy, gray when not
      strokeWeight(0.75); // å‡å°‘çº¿æ¡ç²—ç»†ä»1.5åˆ°0.75
      rect(buttonBoxX, buttonBoxY, buttonBoxWidth, buttonBoxHeight, 8); // Rounded corners
      
      // å³ä¾§æ–‡æœ¬æ¡†
      let rightBoxWidth = width * 0.25; // å³ä¾§æ–‡æœ¬æ¡†å®½åº¦ä¹Ÿç¨çª„
      let rightBoxX = width*5/6 - rightBoxWidth/2; // åœ¨å³ä¾§ä¸‰åˆ†ä¹‹ä¸€åŒºåŸŸå±…ä¸­
      fill(40, 40, 60, 240);
      stroke(150);
      strokeWeight(0.75);
      rect(rightBoxX, buttonBoxY, rightBoxWidth, buttonBoxHeight, 8);
      
      // å·¦ä¾§æ–‡æœ¬æ¡†çš„æ–‡å­—
      fill(255, 220, 220); // æµ…ç²‰è‰²æ–‡å­—ï¼Œä¸ä¸­é—´æ¡†ç›¸åŒ
      textSize(14); // å‡å°å­—ä½“ç¡®ä¿æ–‡å­—é€‚åˆæ–‡æœ¬æ¡†å®½åº¦
      textAlign(CENTER, CENTER);
      text("This real-time mesh is rendered using", leftBoxX + leftBoxWidth/2, buttonBoxY + 25);
      text("Mediapipe + p5.js.", leftBoxX + leftBoxWidth/2, buttonBoxY + 45);
      
      textSize(12); // æ›´å°çš„å­—ä½“ç”¨äºç¬¬äºŒæ®µè¾ƒé•¿çš„æ–‡å­—
      fill(200, 200, 255); // æµ…è“è‰²æ–‡å­—ï¼Œä¸ä¸­é—´æ¡†ç›¸åŒ
      text("It only detects a smile to trigger the", leftBoxX + leftBoxWidth/2, buttonBoxY + 75);
      text("interaction. No data is saved or uploaded.", leftBoxX + leftBoxWidth/2, buttonBoxY + 95);
      
      // ä¸­é—´æ–‡æœ¬æ¡†çš„æ–‡å­—
      // Hint Text
      textAlign(CENTER, CENTER);
      if (!isHappy) {
        fill(255, 200, 200); // Light pink for the "smile to unlock" text
        textSize(16); // Slightly larger
        text("Smile to unlock the [Capture] button", captureButton.x + 36, buttonBoxY + 25);
      } else {
        fill(255, 220, 220); // Light pink even when happy
        textSize(16);
        text("Click the [Capture] button", captureButton.x + 36, buttonBoxY + 25);
      }
      
      // Always show the formatting message
      fill(200, 200, 255); // Light blue for the second line
      textSize(14);
      text("Your selfie will be formatted by the platform", captureButton.x + 36, buttonBoxY + 60);
      
      // å³ä¾§æ–‡æœ¬æ¡†çš„æ–‡å­—
      fill(255, 220, 220);
      textSize(14);
      text("These are the platform-approved", rightBoxX + rightBoxWidth/2, buttonBoxY + 35);
      text("versions of you.", rightBoxX + rightBoxWidth/2, buttonBoxY + 60);
      
      // å¯ä»¥æ·»åŠ ç¬¬äºŒæ®µæ–‡å­—ï¼Œä¸å·¦ä¾§æ–‡æœ¬æ¡†ç»“æ„ç±»ä¼¼
      fill(200, 200, 255);
      textSize(12);
      
      // ä¿®æ”¹å·²æ‹æ‘„æ•°é‡æ˜¾ç¤ºï¼Œåˆ†æˆä¸‰éƒ¨åˆ†ï¼Œä¸­é—´æ•°å­—éƒ¨åˆ†ç”¨é»„è‰²åŠ ç²—æ˜¾ç¤º
      let photoCountPrefix = "Photos: ";
      let photoCountSuffix = "";
      
      // è®¡ç®—æ–‡æœ¬å®½åº¦ä»¥ç¡®ä¿æ­£ç¡®å¯¹é½
      let prefixWidth = textWidth(photoCountPrefix);
      let countWidth = textWidth(String(photoList.length));
      let totalWidth = prefixWidth + countWidth + textWidth(photoCountSuffix);
      
      // è®¡ç®—èµ·å§‹Xåæ ‡ï¼Œä½¿æ•´ä½“æ–‡æœ¬å±…ä¸­
      let startX = rightBoxX + rightBoxWidth/2 - totalWidth/2;
      
      // ç»˜åˆ¶å‰ç¼€
      text(photoCountPrefix, startX + prefixWidth/2, buttonBoxY + 95);
      
      // ç»˜åˆ¶æ•°å­—éƒ¨åˆ†ï¼ˆé»„è‰²åŠ ç²—ï¼‰
      push();
      fill(255, 235, 59); // é»„è‰² #FFEB3B
      textStyle(BOLD); // åŠ ç²—
      
      // ç»˜åˆ¶è½»å¾®åç§»çš„å‰¯æœ¬æ¥å¢å¼ºåŠ ç²—æ•ˆæœ
      text(photoList.length, startX + prefixWidth + countWidth/2 - 0.5, buttonBoxY + 95 - 0.5);
      text(photoList.length, startX + prefixWidth + countWidth/2 + 0.5, buttonBoxY + 95 - 0.5);
      text(photoList.length, startX + prefixWidth + countWidth/2 - 0.5, buttonBoxY + 95 + 0.5);
      text(photoList.length, startX + prefixWidth + countWidth/2 + 0.5, buttonBoxY + 95 + 0.5);
      
      // ä¸­é—´ç»˜åˆ¶ä¸»è¦æ–‡æœ¬
      text(photoList.length, startX + prefixWidth + countWidth/2, buttonBoxY + 95);
      pop();
      
      // ç»˜åˆ¶åç¼€
      fill(200, 200, 255);
      text(photoCountSuffix, startX + prefixWidth + countWidth + textWidth(photoCountSuffix)/2, buttonBoxY + 95);
      
      textAlign(CENTER, CENTER); // Reset text alignment
      pop();
      // +++ End æ–‡æœ¬æ¡†ç»˜åˆ¶ +++

      // ç„¶åç»˜åˆ¶è§†é¢‘èƒŒæ™¯
      drawVideoBackground();

      // +++ NEW: Always draw the background overlay +++
      // Calculate dimensions needed for the overlay
      let artTopLeftX = captureCenterPos.x - myCapture.width / 2 - 4;
      let artTopLeftY = captureCenterPos.y - myCapture.height / 2 - 4;
      let artWidth = myCapture.width + 8;
      let artHeight = myCapture.height + 8;
      
      push();
      noStroke();
      // 1. Draw base dark background
      fill(30, 30, 45); // è°ƒæ•´ä¸ºæ›´æ¥è¿‘èƒŒæ™¯è‰²(30, 30, 50)
      rect(artTopLeftX, artTopLeftY, artWidth, artHeight, 5);
      // 2. Draw hazy overlay
      fill(245, 237, 246, 20); // #f5edf6 with even lower alpha
      rect(artTopLeftX, artTopLeftY, artWidth, artHeight, 5); // Draw again on top
      pop();
      // +++ END Always draw background overlay +++

      // æœ€åç»˜åˆ¶æŒ‰é’®ï¼Œç¡®ä¿æŒ‰é’®åœ¨æœ€ä¸Šå±‚
      // Set button color based on isHappy state
      if (isHappy) {
        fill(255, 100, 150); // Active/Happy color (e.g., pink)
      } else {
        fill(204); // Inactive/Gray color
      }
      noStroke();
      rect(captureButton.x, captureButton.y + 60, captureButton.w, captureButton.h, 4); // å‘ä¸‹ç§»åŠ¨60åƒç´ 
      textSize(18)
      fill(255)
      text('Capture', captureButton.x + 50, captureButton.y + 60 + 21) // è°ƒæ•´ä¸ºæŒ‰é’®ä¸­å¤® (100/2=50)

      for (let i = 0; i < photoList.length; i++) {
        let photo = photoList[i];
        photo.display();
        photo.update();
      }

      // æ›´æ–°æ‹–åŠ¨é€»è¾‘
      if (handPoint4 && handPoint8) {
        const pinchDistance = dist(handPoint4.x, handPoint4.y, handPoint8.x, handPoint8.y);
        
        // å¦‚æœæ­£åœ¨æ‹–åŠ¨ç…§ç‰‡
        if (draggedPhoto) {
          if (pinchDistance < 40) {
            // å¹³æ»‘ç§»åŠ¨ç…§ç‰‡åˆ°æ‰‹æŒ‡ä½ç½®
            const targetX = handPoint4.x;
            const targetY = handPoint4.y;
            draggedPhoto.pos.x = lerp(draggedPhoto.pos.x, targetX, 0.3);
            draggedPhoto.pos.y = lerp(draggedPhoto.pos.y, targetY, 0.3);
            draggedPhoto.angle = -0.2;
          } else {
            // å¦‚æœæ‰‹æŒ‡åˆ†å¼€ï¼Œé‡Šæ”¾ç…§ç‰‡
            draggedPhoto = null;
          }
        } else {
          // æ£€æŸ¥æ˜¯å¦å¯ä»¥å¼€å§‹æ‹–åŠ¨æ–°ç…§ç‰‡
          if (pinchDistance < 40) {
            // ä»åå¾€å‰éå†ç…§ç‰‡åˆ—è¡¨ï¼Œä¼˜å…ˆé€‰æ‹©æœ€ä¸Šå±‚çš„ç…§ç‰‡
            for (let i = photoList.length - 1; i >= 0; i--) {
              let photo = photoList[i];
              if (handPoint4.x > photo.pos.x - photo.img.width / 2 && 
                  handPoint4.x < photo.pos.x + photo.img.width / 2 && 
                  handPoint4.y > photo.pos.y - photo.img.height / 2 && 
                  handPoint4.y < photo.pos.y + photo.img.height / 2) {
                draggedPhoto = photo;
                break;
              }
            }
          }
        }
      } else if (draggedPhoto) {
        // å¦‚æœæ£€æµ‹ä¸åˆ°æ‰‹éƒ¨å…³é”®ç‚¹ï¼Œä¿æŒç…§ç‰‡å½“å‰ä½ç½®
        draggedPhoto.angle = 0;
      }

      fill(0)
      // text("å•æ¬¡æ‹ç…§æ•°é‡ï¼š" + captureNumSlider.value(), width / 2 + 1, height / 2 - 25 + 1)
      let sliderTextY = captureNumSlider.y + 35; // Position text relative to slider's new position
      text("Photos per capture: " + captureNumSlider.value(), width / 2 + 1, sliderTextY + 1);
      fill(255);
      // text("å•æ¬¡æ‹ç…§æ•°é‡ï¼š" + captureNumSlider.value(), width / 2, height / 2 - 25)
      text("Photos per capture: " + captureNumSlider.value(), width / 2, sliderTextY);

      predictWebcam();
      drawHandPoints();
      drawFacePoints();

      // +++ Mixed ASCII Art and Emoji Generation +++
      try {
        // åªåœ¨æ£€æµ‹åˆ°äººè„¸æ—¶è¿›è¡Œå¤„ç†
        if (faceLandmarks && faceLandmarks.faceLandmarks && faceLandmarks.faceLandmarks.length > 0) {
          let landmarks = faceLandmarks.faceLandmarks[0];
          
          // --- REMOVED overlay dimension calculation from here ---
          // let artTopLeftX = captureCenterPos.x - myCapture.width / 2 - 4; 
          // let artTopLeftY = captureCenterPos.y - myCapture.height / 2 - 4;
          // let artWidth = myCapture.width + 8; 
          // let artHeight = myCapture.height + 8;

          if (showAsciiArt) { // Only run if showAsciiArt is true
          // --- REMOVED overlay dimension calculation from here too ---
          // let artTopLeftX = captureCenterPos.x - myCapture.width / 2 - 4; // ç•¥å¾®æ‰©å±•ä»¥åŒ¹é…ç™½è‰²è¾¹æ¡†
          // let artTopLeftY = captureCenterPos.y - myCapture.height / 2 - 4;
          // let artWidth = myCapture.width + 8; // ç•¥å¾®æ‰©å±•ä»¥åŒ¹é…ç™½è‰²è¾¹æ¡†
          // let artHeight = myCapture.height + 8;
          
          // è®¡ç®—å•å…ƒæ ¼æ•°é‡
          let cols = floor(artWidth / cellSize);
          let rows = floor(artHeight / cellSize);
            
            // +++ Calculate Face Bounding Box (Normalized) +++
            let faceMinX = 1, faceMaxX = 0, faceMinY = 1, faceMaxY = 0;
            if (landmarks && landmarks.length > 0) {
                for (const point of landmarks) {
                    faceMinX = min(faceMinX, point.x);
                    faceMaxX = max(faceMaxX, point.x);
                    faceMinY = min(faceMinY, point.y);
                    faceMaxY = max(faceMaxY, point.y);
                }
            }
            // +++ End Face Bounding Box Calculation +++
          
          // ä¸ºemojiæ•ˆæœåˆ›å»ºè¾ƒå¤§çš„å•å…ƒæ ¼
          let emojiCols = floor(artWidth / cellSizeEmoji);
          let emojiRows = floor(artHeight / cellSizeEmoji);
          
          // ç»˜åˆ¶é»‘è‰²èƒŒæ™¯ä»¥å®Œå…¨è¦†ç›–åŸå§‹æ‘„åƒå¤´ç”»é¢
          push();
          // --- REMOVED Background drawing from here --- 
          // fill(20, 30, 120, 100); // Change background to deep blue with low opacity - REMOVED
          noStroke();
            
            // 1. Draw base dark background
            fill(30, 30, 45); // è°ƒæ•´ä¸ºæ›´æ¥è¿‘èƒŒæ™¯è‰²(30, 30, 50)
            rect(artTopLeftX, artTopLeftY, artWidth, artHeight, 5);
            
            // 2. Draw hazy overlay
            fill(245, 237, 246, 20); // #f5edf6 with even lower alpha
            rect(artTopLeftX, artTopLeftY, artWidth, artHeight, 5); // Draw again on top
            
            // ç»˜åˆ¶èƒŒæ™¯ç‚¹ç½‘æ ¼ (ç±»ä¼¼äºå‚è€ƒå›¾åƒä¸­çš„åœ†ç‚¹)
            fill(80); // Keep dots visible enough on the new background
          for (let y = 0; y <= rows; y++) {
            for (let x = 0; x <= cols; x++) {
              ellipse(artTopLeftX + x * cellSize, artTopLeftY + y * cellSize, 2, 2);
            }
          }
          
          // ç”Ÿæˆå’Œç»˜åˆ¶ASCIIå›¾æ ‡è‰ºæœ¯
          textSize(cellSize);
          textAlign(CENTER, CENTER);
          
          // åªåœ¨è¾¾åˆ°æ›´æ–°é—´éš”æ—¶æ‰æ›´æ–°ASCIIå­—ç¬¦
          const currentTime = millis();
          if (currentTime - lastAsciiUpdateTime > ASCII_UPDATE_INTERVAL || asciiCharacters.length === 0) {
            // æ›´æ–°ASCIIå­—ç¬¦
            lastAsciiUpdateTime = currentTime;
            
            // æ¸…ç©ºç°æœ‰çš„ASCIIå­—ç¬¦æ•°ç»„
            asciiCharacters = [];
            
            // ä¸ºæ¯ä¸ªå•å…ƒæ ¼é€‰æ‹©ä¸€ä¸ªæ–°çš„å­—ç¬¦
            for (let y = 0; y < rows; y++) {
              asciiCharacters[y] = [];
                // +++ Define Face Area Colors +++
                const faceColors = [
                  [64, 93, 230],   // #405de6
                  [131, 58, 180],  // #833ab4
                  [225, 48, 108],  // #e1306c
                  [255]            // White
                ];
                // +++ End Define Face Area Colors +++
              for (let x = 0; x < cols; x++) {
                // è®¡ç®—å½“å‰å›¾æ ‡å¯¹åº”çš„æ‘„åƒå¤´åƒç´ ä½ç½®
                let camX = floor(map(x, 0, cols, myCapture.width, 0)); // è€ƒè™‘é•œåƒæ•ˆæœ
                let camY = floor(map(y, 0, rows, 0, myCapture.height));
                                     
                  // Calculate normalized coordinates for face check
                  let normX = map(camX, 0, myCapture.width, 0, 1);
                  let normY = map(camY, 0, myCapture.height, 0, 1);
                                   
                // ç¡®ä¿åæ ‡åœ¨æœ‰æ•ˆèŒƒå›´å†…
                if (camX >= 0 && camX < myCapture.width && camY >= 0 && camY < myCapture.height) {
                  // è·å–æ‘„åƒå¤´åœ¨è¯¥ä½ç½®çš„åƒç´ é¢œè‰²
                    // myCapture.loadPixels(); // REMOVED - Called once per frame now
                  let index = (camY * myCapture.width + camX) * 4;
                  
                  if (index < myCapture.pixels.length - 3) {
                    let r = myCapture.pixels[index];
                    let g = myCapture.pixels[index + 1];
                    let b = myCapture.pixels[index + 2];
                    
                    // è®¡ç®—äº®åº¦ï¼Œä½¿ç”¨æ„ŸçŸ¥äº®åº¦å…¬å¼
                    let brightness = 0.299 * r + 0.587 * g + 0.114 * b;
                    
                    // åªæœ‰äº®åº¦è¶…è¿‡é˜ˆå€¼æ—¶æ‰ç»˜åˆ¶å›¾æ ‡ï¼ˆåˆ›å»ºå›¾åƒè½®å»“ï¼‰
                    if (brightness > 100) {
                      // æ ¹æ®äº®åº¦éšæœºé€‰æ‹©å›¾æ ‡/ç¬¦å·
                      let charIndex = floor(random(iconChars.length));
                      let iconToDisplay = iconChars[charIndex];
                        
                        // +++ Determine Color based on Face Bounding Box +++
                        let charColor = [200, 150]; // Default: grayish-white with alpha
                        if (normX >= faceMinX && normX <= faceMaxX && normY >= faceMinY && normY <= faceMaxY) {
                            // charColor = [255]; // Inside face: white (fully opaque) - REMOVED
                            // Inside face: randomly choose light purple or pinkish-white (fully opaque) - REMOVED OLD LOGIC
                            // if (random() < 0.5) { ... } else { ... } - REMOVED OLD LOGIC
                            
                            // Randomly select one of the four new face colors
                            charColor = faceColors[floor(random(faceColors.length))];
                        }
                        // +++ End Determine Color +++
                      
                      // å­˜å‚¨ASCIIå­—ç¬¦ä¿¡æ¯
                      asciiCharacters[y][x] = {
                        char: iconToDisplay,
                        x: artTopLeftX + x * cellSize + cellSize / 2,
                        y: artTopLeftY + y * cellSize + cellSize / 2,
                          visible: true,
                          color: charColor // Store the determined color
                      };
                    } else {
                      asciiCharacters[y][x] = { visible: false };
                    }
                  } else {
                    asciiCharacters[y][x] = { visible: false };
                  }
                } else {
                  asciiCharacters[y][x] = { visible: false };
                }
              }
            }
          }
          
          // ç»˜åˆ¶å­˜å‚¨çš„ASCIIå­—ç¬¦
          for (let y = 0; y < asciiCharacters.length; y++) {
            for (let x = 0; x < asciiCharacters[y].length; x++) {
              if (asciiCharacters[y][x].visible) {
                  fill(asciiCharacters[y][x].color); // Use stored color
                text(asciiCharacters[y][x].char, asciiCharacters[y][x].x, asciiCharacters[y][x].y);
              }
            }
          }
          
          // å¦‚æœç”¨æˆ·å¾®ç¬‘ï¼Œæ·»åŠ å½©è‰²emojiç‚¹ç¼€
          if (isHappy) {
            // ä½¿ç”¨è¾ƒå¤§çš„æ–‡æœ¬å¤§å°ç»˜åˆ¶emoji
            textSize(cellSizeEmoji);
            
            // ç»˜åˆ¶å­˜å‚¨çš„emoji
            if (emojiPositions && emojiPositions.length > 0) {
                fill(255, 255, 255, 180); // Set fill with alpha for emojis
              for (let emoji of emojiPositions) {
                text(emoji.emoji, emoji.x, emoji.y);
              }
            }
          }
          
          pop();
          textFont('Manrope'); // <<<< SWITCH BACK TO DEFAULT FONT AFTER ASCII BLOCK
          } else {
             // If ASCII art is hidden, NO need to draw background here anymore
            // push();
            // noStroke();
            // // 1. Draw base dark background
            // fill(30, 30, 45); // è°ƒæ•´ä¸ºæ›´æ¥è¿‘èƒŒæ™¯è‰²(30, 30, 50)
            // rect(artTopLeftX, artTopLeftY, artWidth, artHeight, 5);
            // // 2. Draw hazy overlay
            // fill(245, 237, 246, 20); // #f5edf6 with even lower alpha
            // rect(artTopLeftX, artTopLeftY, artWidth, artHeight, 5); // Draw again on top
            // pop();
          }
        }
      } catch (error) {
        console.error('Error generating mixed art:', error);
        // å³ä½¿ç”Ÿæˆå¤±è´¥ï¼Œä¹Ÿå…è®¸åº”ç”¨ç»§ç»­è¿è¡Œ
      }

      // æœ€åç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹ï¼Œä¿è¯åœ¨æœ€ä¸Šå±‚
      drawHandPoints();

      // +++ Draw Face Mesh +++
      if (showFaceMesh) { // Only draw if showFaceMesh is true
        drawFaceMesh(); 
      }
      // +++ End Draw Face Mesh +++
      
      // æœ€åç»˜åˆ¶Toggle Buttonsç¡®ä¿åœ¨æœ€ä¸Šå±‚
      // +++ Draw Toggle Buttons +++
      push();
      textSize(16); // å¢å¤§æ–‡æœ¬å¤§å°ä»12åˆ°16
      textAlign(CENTER, CENTER);
      noStroke();
      // Face Mesh Button
      let meshBaseColor = showFaceMesh ? color(80, 50, 120) : color(180, 100, 200); // è°ƒæ¢é¢œè‰²ï¼šHideçŠ¶æ€æš—è‰²ï¼ŒShowçŠ¶æ€äº®è‰²
      let meshDrawColor = meshBaseColor;
      if (mouseX > faceMeshButton.x && mouseX < faceMeshButton.x + faceMeshButton.w && mouseY > faceMeshButton.y && mouseY < faceMeshButton.y + faceMeshButton.h) {
        meshDrawColor = lerpColor(meshBaseColor, color(255), 0.15); // Lighten on hover
      }
      
      // æ·»åŠ æŒ‰é’®å¤–è¾¹æ¡†
      stroke(255, 255, 255, 120); // åŠé€æ˜ç™½è‰²è¾¹æ¡†
      strokeWeight(3); // æ›´ç²—çš„å¤–è¾¹æ¡†
      rect(faceMeshButton.x - 2, faceMeshButton.y - 2, faceMeshButton.w + 4, faceMeshButton.h + 4, 7); // ç•¥å¤§äºæŒ‰é’®çš„å¤–æ¡†
      noStroke();
      
      // ç»˜åˆ¶æŒ‰é’®ä¸»ä½“
      fill(meshDrawColor);
      rect(faceMeshButton.x, faceMeshButton.y, faceMeshButton.w, faceMeshButton.h, 5);
      
      // +++ Simulate Inset Border +++
      let shadowColor = lerpColor(meshDrawColor, color(0), 0.3); // Darker color for shadow
      let highlightColor = lerpColor(meshDrawColor, color(255), 0.2); // Lighter color for highlight
      strokeWeight(2); // å¢åŠ è¾¹æ¡†ç²—ç»†ä»1åˆ°2
      // Top and Left shadow (darker)
      stroke(shadowColor);
      line(faceMeshButton.x + 1, faceMeshButton.y + 1, faceMeshButton.x + faceMeshButton.w - 1, faceMeshButton.y + 1); // Top
      line(faceMeshButton.x + 1, faceMeshButton.y + 1, faceMeshButton.x + 1, faceMeshButton.y + faceMeshButton.h - 1); // Left
      // Bottom and Right highlight (lighter)
      stroke(highlightColor);
      line(faceMeshButton.x + 1, faceMeshButton.y + faceMeshButton.h - 1, faceMeshButton.x + faceMeshButton.w - 1, faceMeshButton.y + faceMeshButton.h - 1); // Bottom
      line(faceMeshButton.x + faceMeshButton.w - 1, faceMeshButton.y + 1, faceMeshButton.x + faceMeshButton.w - 1, faceMeshButton.y + faceMeshButton.h - 1); // Right
      noStroke(); // Reset stroke
      
      // æ·»åŠ å‘å…‰æ•ˆæœ
      drawingContext.shadowColor = showFaceMesh ? 'rgba(180, 100, 220, 0.7)' : 'rgba(200, 150, 255, 0.5)';
      drawingContext.shadowBlur = 8;
      drawingContext.shadowOffsetX = 0;
      drawingContext.shadowOffsetY = 0;
      // +++ End Simulate Inset Border +++

      fill(showFaceMesh ? 255 : 200); // White text if shown, light gray if hidden
      textStyle(BOLD); // æ·»åŠ ç²—ä½“æ–‡æœ¬
      text(showFaceMesh ? "Hide Mesh" : "Open Mesh", faceMeshButton.x + faceMeshButton.w / 2, faceMeshButton.y + faceMeshButton.h / 2);
      textStyle(NORMAL); // æ¢å¤é»˜è®¤æ–‡æœ¬æ ·å¼
      
      // ASCII Art Button
      let asciiBaseColor = showAsciiArt ? color(80, 50, 120) : color(180, 100, 200); // è°ƒæ¢é¢œè‰²ï¼šHideçŠ¶æ€æš—è‰²ï¼ŒShowçŠ¶æ€äº®è‰²
      let asciiDrawColor = asciiBaseColor;
      if (mouseX > asciiArtButton.x && mouseX < asciiArtButton.x + asciiArtButton.w && mouseY > asciiArtButton.y && mouseY < asciiArtButton.y + asciiArtButton.h) {
        asciiDrawColor = lerpColor(asciiBaseColor, color(255), 0.15); // Lighten on hover
      }
      
      // æ·»åŠ æŒ‰é’®å¤–è¾¹æ¡†
      stroke(255, 255, 255, 120); // åŠé€æ˜ç™½è‰²è¾¹æ¡†
      strokeWeight(3); // æ›´ç²—çš„å¤–è¾¹æ¡†
      rect(asciiArtButton.x - 2, asciiArtButton.y - 2, asciiArtButton.w + 4, asciiArtButton.h + 4, 7); // ç•¥å¤§äºæŒ‰é’®çš„å¤–æ¡†
      noStroke();
      
      // ç»˜åˆ¶æŒ‰é’®ä¸»ä½“
      fill(asciiDrawColor);
      rect(asciiArtButton.x, asciiArtButton.y, asciiArtButton.w, asciiArtButton.h, 5);
      
      // +++ Simulate Inset Border +++
      shadowColor = lerpColor(asciiDrawColor, color(0), 0.3);
      highlightColor = lerpColor(asciiDrawColor, color(255), 0.2);
      strokeWeight(2); // å¢åŠ è¾¹æ¡†ç²—ç»†ä»1åˆ°2
      // Top and Left shadow (darker)
      stroke(shadowColor);
      line(asciiArtButton.x + 1, asciiArtButton.y + 1, asciiArtButton.x + asciiArtButton.w - 1, asciiArtButton.y + 1); // Top
      line(asciiArtButton.x + 1, asciiArtButton.y + 1, asciiArtButton.x + 1, asciiArtButton.y + asciiArtButton.h - 1); // Left
      // Bottom and Right highlight (lighter)
      stroke(highlightColor);
      line(asciiArtButton.x + 1, asciiArtButton.y + asciiArtButton.h - 1, asciiArtButton.x + asciiArtButton.w - 1, asciiArtButton.y + asciiArtButton.h - 1); // Bottom
      line(asciiArtButton.x + asciiArtButton.w - 1, asciiArtButton.y + 1, asciiArtButton.x + asciiArtButton.w - 1, asciiArtButton.y + asciiArtButton.h - 1); // Right
      noStroke(); // Reset stroke
      
      // æ·»åŠ å‘å…‰æ•ˆæœ
      drawingContext.shadowColor = showAsciiArt ? 'rgba(180, 100, 220, 0.7)' : 'rgba(200, 150, 255, 0.5)';
      drawingContext.shadowBlur = 8;
      drawingContext.shadowOffsetX = 0;
      drawingContext.shadowOffsetY = 0;
      // +++ End Simulate Inset Border +++
      
      fill(showAsciiArt ? 255 : 200); // White text if shown, light gray if hidden
      textStyle(BOLD); // æ·»åŠ ç²—ä½“æ–‡æœ¬
      text(showAsciiArt ? "Hide ASCII" : "Open ASCII", asciiArtButton.x + asciiArtButton.w / 2, asciiArtButton.y + asciiArtButton.h / 2);
      textStyle(NORMAL); // æ¢å¤é»˜è®¤æ–‡æœ¬æ ·å¼
      pop();
      // +++ End Draw Toggle Buttons +++
    }

    function mousePressed() {
      let mx = mouseX;
      let my = mouseY;
      if (mx > captureButton.x && mx < captureButton.x + captureButton.w && my > captureButton.y + 60 && my < captureButton.y + 60 + captureButton.h) {
        if (isHappy && showAsciiArt) {
          // Play shutter sound with delay when capture is successful
          setTimeout(() => {
            playSound('audio-shutter');
          }, 300);

          for (let i = 0; i < captureNumSlider.value(); i++) {
            handleCapture()
          }
          aaa()
        } else if (!showAsciiArt) {
          // åˆ›å»ºä¸€ä¸ªtoastå…ƒç´ æç¤ºç”¨æˆ·å¯ç”¨ASCIIåŠŸèƒ½
          const toast = document.createElement('div');
          toast.textContent = 'Click the "Open ASCII" button at the top to take photos!';
          toast.style.position = 'fixed';
          toast.style.top = '50%';  // æ”¹ä¸º50%
          toast.style.left = '50%';
          toast.style.transform = 'translate(-50%, -50%)';  // åŒæ—¶å‚ç›´å’Œæ°´å¹³å±…ä¸­
          toast.style.backgroundColor = '#333';
          toast.style.color = '#fff';
          toast.style.padding = '10px 20px';
          toast.style.borderRadius = '5px';
          toast.style.zIndex = '1000';
          document.body.appendChild(toast);

          // æ˜¾ç¤ºä¸€æ®µæ—¶é—´åè‡ªåŠ¨éšè—
          setTimeout(() => {
            toast.style.display = 'none';
          }, 2000);
        } else if (!isHappy) {
          // åˆ›å»ºä¸€ä¸ªtoastå…ƒç´ 
          const toast = document.createElement('div');
          toast.textContent = 'Please keep smiling!';
          toast.style.position = 'fixed';
          toast.style.top = '50%';  // æ”¹ä¸º50%
          toast.style.left = '50%';
          toast.style.transform = 'translate(-50%, -50%)';  // åŒæ—¶å‚ç›´å’Œæ°´å¹³å±…ä¸­
          toast.style.backgroundColor = '#333';
          toast.style.color = '#fff';
          toast.style.padding = '10px 20px';
          toast.style.borderRadius = '5px';
          toast.style.zIndex = '1000';
          document.body.appendChild(toast);

          // æ˜¾ç¤ºä¸€æ®µæ—¶é—´åè‡ªåŠ¨éšè—
          setTimeout(() => {
            toast.style.display = 'none';
          }, 2000);
        }
      }
      
      // +++ Check Toggle Buttons +++
      // Face Mesh Toggle
      if (mx > faceMeshButton.x && mx < faceMeshButton.x + faceMeshButton.w && my > faceMeshButton.y && my < faceMeshButton.y + faceMeshButton.h) {
        showFaceMesh = !showFaceMesh;
      }
      // ASCII Art Toggle
      if (mx > asciiArtButton.x && mx < asciiArtButton.x + asciiArtButton.w && my > asciiArtButton.y && my < asciiArtButton.y + asciiArtButton.h) {
        showAsciiArt = !showAsciiArt;
      }
      // +++ End Check Toggle Buttons +++
    }

    function drawVideoBackground() {
      push();
      translate(captureCenterPos.x, captureCenterPos.y);
      noStroke();
      fill(255);
      rect(-myCapture.width / 2 - 4, -myCapture.height / 2 - 4, myCapture.width + 8, myCapture.height + 8, 5);
      
      // ç»˜åˆ¶æ‘„åƒå¤´ç”»é¢ï¼Œè‰ºæœ¯æ•ˆæœå°†è¦†ç›–äººè„¸éƒ¨åˆ†
      scale(-1, 1);
      image(myCapture, 0, 0);
      
      pop();
    }

    let handPoint4, handPoint8;
    function drawHandPoints() {
      if (trackingConfig.doAcquireHandLandmarks) {
        if (handLandmarks && handLandmarks.landmarks) {
          const nHands = handLandmarks.landmarks.length;
          if (nHands > 0) {
            let joints = handLandmarks.landmarks[0];

            fill(116, 233, 79)
            let px4 = joints[4].x;
            let py4 = joints[4].y;
            px4 = map(px4, 0, 1, width, 0);
            py4 = map(py4, 0, 1, 0, height);
            circle(px4, py4, 12);
            handPoint4 = {
              x: px4,
              y: py4
            }

            let px8 = joints[8].x;
            let py8 = joints[8].y;
            px8 = map(px8, 0, 1, width, 0);
            py8 = map(py8, 0, 1, 0, height);
            circle(px8, py8, 12);
            handPoint8 = {
              x: px8,
              y: py8
            }
          }
        }
      }
    }

    function drawFacePoints() {
      if (trackingConfig.doAcquireFaceLandmarks) {
        if (faceLandmarks && faceLandmarks.faceLandmarks) {

          // --- Keep logic to update isHappy ---
          isHappy = false
          if (faceLandmarks?.faceBlendshapes?.[0]?.categories) {
            let data = faceLandmarks.faceBlendshapes[0].categories.map((item) => {
              return {
                score: Number(item.score.toFixed(2)),
                categoryName: item.categoryName,
              };
            });
            const scores = Object.fromEntries(data.map(item => [item.categoryName, item.score]));
            // You might want to refine this condition further based on testing
            if (scores.mouthSmileLeft > 0.3 || scores.mouthSmileRight > 0.3) { // Keep your original || or change to && if preferred
              isHappy = true;
            }
          }
          // --- End isHappy update logic ---
        }
      }
    }

    function handleCapture() {
      // åˆ›å»ºä¸€ä¸ªæ–°ç”»å¸ƒæ¥æ¸²æŸ“è‰ºæœ¯æ•ˆæœ
      let artCanvas = createGraphics(300, 300);
      
      myCapture.loadPixels(); // Load pixels once at the start of capture
      
      // è®¾ç½®æ–‡æœ¬å±æ€§
      artCanvas.textFont('Manrope'); // Set Manrope as default for capture canvas
      artCanvas.textAlign(CENTER, CENTER);
      artCanvas.noStroke();
      
      // ç»˜åˆ¶é»‘è‰²èƒŒæ™¯
      // artCanvas.fill(20, 30, 120, 100); // Change background to deep blue with low opacity - REMOVED
      
      // 1. Draw base dark background for capture
      artCanvas.fill(30, 30, 45); // è°ƒæ•´ä¸ºæ›´æ¥è¿‘èƒŒæ™¯è‰²(30, 30, 50)
      artCanvas.rect(0, 0, 300, 300);
      
      // 2. Draw hazy overlay for capture
      artCanvas.fill(245, 237, 246, 20); // #f5edf6 with even lower alpha
      artCanvas.rect(0, 0, 300, 300); // Draw again on top
      
      // è®¡ç®—å•å…ƒæ ¼æ•°é‡
      let cols = floor(300 / cellSize);
      let rows = floor(300 / cellSize);
      
      // åˆ›å»ºèƒŒæ™¯ç‚¹ç½‘æ ¼
      artCanvas.fill(255); // This fill is for the background dots, keep it lighter than main bg
      artCanvas.fill(80); // Use the same dot color as in draw()
      for (let y = 0; y <= rows; y++) {
        for (let x = 0; x <= cols; x++) {
          artCanvas.ellipse(x * cellSize, y * cellSize, 2, 2);
        }
      }
      
      // æ£€æŸ¥asciiCharactersæ˜¯å¦å­˜åœ¨åŠå…¶é•¿åº¦
      if (asciiCharacters && asciiCharacters.length > 0) {
        // Only draw ASCII characters to the photo if the effect is currently shown
        if (showAsciiArt && asciiCharacters && asciiCharacters.length > 0) {
        // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
        const scaleX = 300 / (myCapture.width + 8);
        const scaleY = 300 / (myCapture.height + 8);
        
        // ç›´æ¥ä½¿ç”¨å½“å‰å±å¹•ä¸Šçš„ASCIIå­—ç¬¦
        artCanvas.textFont('monospace'); // <<<< SET MONOSPACE FOR ASCII
        artCanvas.textSize(cellSize);
        artCanvas.fill(255);
        
        for (let y = 0; y < asciiCharacters.length; y++) {
          if (asciiCharacters[y]) {  // ç¡®ä¿è¡Œå­˜åœ¨
            for (let x = 0; x < asciiCharacters[y].length; x++) {
              if (asciiCharacters[y][x] && asciiCharacters[y][x].visible) {
                try {
                  // è®¡ç®—åœ¨æ–°ç”»å¸ƒä¸Šçš„ä½ç½®
                  let newX = x * cellSize + cellSize/2;
                  let newY = y * cellSize + cellSize/2;
                  
                  // ç»˜åˆ¶å­—ç¬¦
                    artCanvas.fill(asciiCharacters[y][x].color); // Use stored color
                  artCanvas.text(asciiCharacters[y][x].char, newX, newY);
                } catch (e) {
                  console.error("Error drawing ASCII character:", e);
                }
                }
              }
            }
          }
        } else if (showAsciiArt) {
          // å¦‚æœæ²¡æœ‰ç°æœ‰ASCIIå­—ç¬¦ï¼Œåˆ™ç”Ÿæˆæ–°çš„
          artCanvas.textFont('monospace'); // <<<< SET MONOSPACE FOR ASCII
          artCanvas.textSize(cellSize);
          for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
              // è·å–æ‘„åƒå¤´åœ¨è¯¥ä½ç½®çš„åƒç´ é¢œè‰²
              try {
                // myCapture.loadPixels(); // REMOVED - Called once at start of handleCapture now
                let camX = floor(map(x, 0, cols, myCapture.width, 0));
                let camY = floor(map(y, 0, rows, 0, myCapture.height));
                
                if (camX >= 0 && camX < myCapture.width && camY >= 0 && camY < myCapture.height) {
                  let index = (camY * myCapture.width + camX) * 4;
                  
                  if (index < myCapture.pixels.length - 3) {
                    let r = myCapture.pixels[index];
                    let g = myCapture.pixels[index + 1];
                    let b = myCapture.pixels[index + 2];
                    
                    // è®¡ç®—äº®åº¦
                    let brightness = 0.299 * r + 0.587 * g + 0.114 * b;
                    
                    // åªæœ‰äº®åº¦è¶…è¿‡é˜ˆå€¼æ—¶æ‰ç»˜åˆ¶å›¾æ ‡
                    if (brightness > 100) {
                      let charIndex = floor(random(iconChars.length));
                      let iconToDisplay = iconChars[charIndex];
                      
                      // ç»˜åˆ¶ASCIIå­—ç¬¦
                      artCanvas.fill(200, 150); // Default color (grayish-white with alpha) for fallback generation
                      
                      // +++ Check if inside face (needs recalculation here) +++
                      // This fallback generation path doesn't have the face box easily available.
                      // We'll stick to the default grayish-white for simplicity in this rare case.
                      // To implement perfectly, we'd need to pass face box data or recalculate.
                      // +++ End Check +++
                      
                      artCanvas.text(iconToDisplay, x * cellSize + cellSize/2, y * cellSize + cellSize/2);
                    }
                  }
                }
              } catch (e) {
                console.error("Error processing pixel:", e);
              }
            }
          }
        }
      } else {
        // å¦‚æœæ²¡æœ‰ç°æœ‰ASCIIå­—ç¬¦ï¼Œåˆ™ç”Ÿæˆæ–°çš„
        artCanvas.textFont('monospace'); // <<<< SET MONOSPACE FOR ASCII
        artCanvas.textSize(cellSize);
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            // è·å–æ‘„åƒå¤´åœ¨è¯¥ä½ç½®çš„åƒç´ é¢œè‰²
            try {
              // myCapture.loadPixels(); // REMOVED - Called once at start of handleCapture now
              let camX = floor(map(x, 0, cols, myCapture.width, 0));
              let camY = floor(map(y, 0, rows, 0, myCapture.height));
              
              if (camX >= 0 && camX < myCapture.width && camY >= 0 && camY < myCapture.height) {
                let index = (camY * myCapture.width + camX) * 4;
                
                if (index < myCapture.pixels.length - 3) {
                  let r = myCapture.pixels[index];
                  let g = myCapture.pixels[index + 1];
                  let b = myCapture.pixels[index + 2];
                  
                  // è®¡ç®—äº®åº¦
                  let brightness = 0.299 * r + 0.587 * g + 0.114 * b;
                  
                  // åªæœ‰äº®åº¦è¶…è¿‡é˜ˆå€¼æ—¶æ‰ç»˜åˆ¶å›¾æ ‡
                  if (brightness > 100) {
                    let charIndex = floor(random(iconChars.length));
                    let iconToDisplay = iconChars[charIndex];
                    
                    // ç»˜åˆ¶ASCIIå­—ç¬¦
                    artCanvas.fill(200, 150); // Default color (grayish-white with alpha) for fallback generation
                    
                    // +++ Check if inside face (needs recalculation here) +++
                    // This fallback generation path doesn't have the face box easily available.
                    // We'll stick to the default grayish-white for simplicity in this rare case.
                    // To implement perfectly, we'd need to pass face box data or recalculate.
                    // +++ End Check +++
                    
                    artCanvas.text(iconToDisplay, x * cellSize + cellSize/2, y * cellSize + cellSize/2);
                  }
                }
              }
            } catch (e) {
              console.error("Error processing pixel:", e);
            }
          }
        }
      }
      
      // å¦‚æœç”¨æˆ·å¾®ç¬‘ï¼Œæ·»åŠ emoji
      if (isHappy) {
        artCanvas.textFont('Manrope'); // <<<< SWITCH BACK FOR EMOJI (or default)
        artCanvas.textSize(cellSizeEmoji);
        
        if (emojiPositions && emojiPositions.length > 0) {
          // ä½¿ç”¨ç°æœ‰emojiä½ç½®
          try {
            // åœ¨åº•éƒ¨ç»˜åˆ¶ä¸€è¡Œemoji
            let numEmojis = emojiPositions.length;
            let totalWidth = numEmojis * cellSizeEmoji;
            let startX = (300 - totalWidth) / 2;
            let emojiY = 300 - cellSizeEmoji; // åº•éƒ¨ä½ç½®
            
            artCanvas.fill(255, 255, 255, 180); // Set fill before loop for emojis
            for (let i = 0; i < numEmojis; i++) {
              let emojiX = startX + i * cellSizeEmoji + cellSizeEmoji/2;
              artCanvas.text(emojiPositions[i].emoji, emojiX, emojiY);
            }
          } catch (e) {
            console.error("Error drawing emojis:", e);
          }
        } else {
          // å¦‚æœæ²¡æœ‰ç°æœ‰emojiï¼Œåˆ™ç”Ÿæˆæ–°çš„
          let numEmojis = floor(random(3, 7));
          let totalWidth = numEmojis * cellSizeEmoji;
          let startX = (300 - totalWidth) / 2;
          let emojiY = 300 - cellSizeEmoji; // åº•éƒ¨ä½ç½®
          
          artCanvas.fill(255, 255, 255, 180); // Set fill before loop for emojis
          for (let i = 0; i < numEmojis; i++) {
            let randomEmoji = happyEmojis[floor(random(happyEmojis.length))];
            let emojiX = startX + i * cellSizeEmoji + cellSizeEmoji/2;
            artCanvas.text(randomEmoji, emojiX, emojiY);
          }
        }
      }
      
      // +++ Calculate Target Position in Right Grid Exhibition Area (3x6 Grid with Wrap-around) +++
      let maxSlots = exhibitionArea.cols * exhibitionArea.maxRows;
      let targetSlotIndex = nextPhotoIndex % maxSlots; // Index wraps around 0-17
      let col = targetSlotIndex % exhibitionArea.cols;
      let row = floor(targetSlotIndex / exhibitionArea.cols);
      let targetX = exhibitionArea.startX + col * (exhibitionArea.photoSize + exhibitionArea.spacing) + exhibitionArea.photoSize / 2;
      let targetY = exhibitionArea.startY + row * (exhibitionArea.photoSize + exhibitionArea.spacing) + exhibitionArea.photoSize / 2;
      let targetPos = createVector(targetX, targetY);
      nextPhotoIndex++; // Increment total photo count
      // +++ End Calculate Target Position +++
      
      // åˆ›å»ºæ•è·çš„å›¾åƒ
      let photoNumber = nextPhotoIndex; // Use total count for label, starting from 1
      let wasSmiling = isHappy; // Capture the smiling state
      let photo = new MyPhoto(artCanvas, targetPos, photoNumber, wasSmiling); // Pass number and state
      
      // +++ Overwrite logic: Keep only the latest 18 photos +++
      if (photoList.length >= maxSlots) {
        photoList.shift(); // Remove the oldest photo from the beginning of the array
      }
      photoList.push(photo);
      // +++ End Overwrite logic +++
    }

    class MyPhoto {
      constructor(img, targetPos, number, smiling) { // Accept number and smiling state
        if (img instanceof p5.Graphics) {
          // å¦‚æœæ˜¯å›¾å½¢å¯¹è±¡ï¼Œè½¬æ¢ä¸ºå›¾åƒ
          this.img = createImage(img.width, img.height);
          this.img.copy(img, 0, 0, img.width, img.height, 0, 0, img.width, img.height);
          img.remove(); // é‡Šæ”¾å›¾å½¢å¯¹è±¡
        } else {
          this.img = img;
        }
        this.img.resize(photoDisplaySize, photoDisplaySize); // Use defined display size
        this.pos = createVector(captureCenterPos.x, captureCenterPos.y); // Start at capture center
        this.angle = PI;
        this.targetPos = targetPos; // Use the passed target position
        this.initDist = dist(this.pos.x, this.pos.y, this.targetPos.x, this.targetPos.y); // Calculate initial distance
        this.done = false;
        this.number = number; // Store the photo number
        this.smiling = smiling; // Store the smiling state
      }

      display() {
        push();
        translate(this.pos.x, this.pos.y);
        rotate(this.angle);
        fill(255)
        drawingContext.shadowOffsetX = 0;
        drawingContext.shadowOffsetY = 0;
        drawingContext.shadowBlur = 15;
        drawingContext.shadowColor = 'rgb(50, 50, 50)';
        rect(-54, -54, 108, 108, 4)
        drawingContext.shadowBlur = 0;
        image(this.img, 0, 0);
        pop();

        // +++ Add Hover Information Label +++
        if (this.done) { // Only show label when photo is in place
            let hoverDist = dist(mouseX, mouseY, this.pos.x, this.pos.y);
            if (hoverDist < this.img.width / 2) { // Check if mouse is over the photo
                push();
                translate(this.pos.x, this.pos.y); // Position in the middle of the photo
                fill(0, 0, 0, 180); // Semi-transparent black background
                noStroke();
                let labelText = `ğŸ“· #${this.number}\npositive emotion: detected`;
                let textW = textWidth(labelText.split('\n')[0]) + 10; // Get width of first line
                let textH = 35; // Approximate height for two lines
                rect(-textW/2, -textH/2, textW, textH, 5); // Draw background rect

                textFont('Manrope'); // <<<< Ensure Manrope for label
                fill(255); // White text
                textSize(12);
                textAlign(CENTER, CENTER);
                text(labelText, 0, 0);
        pop();
            }
        }
        // +++ End Hover Information Label +++
      }

      update() {
        if (!this.done) {
          // åˆå§‹é€Ÿåº¦æ›´å¿«ï¼Œéšç€æ¥è¿‘ç›®æ ‡å‡æ…¢
          let initialSpeed = 45; // åˆå§‹é€Ÿåº¦æé«˜åˆ°45
          let minSpeed = 18; // æœ€å°é€Ÿåº¦ä¿æŒä¸º18
          
          let curDist = this.pos.dist(this.targetPos);
          let progress = curDist / this.initDist; // æ¥è¿‘ç›®æ ‡çš„è¿›åº¦æ¯”ä¾‹
          
          // æ ¹æ®è·ç¦»è®¡ç®—å½“å‰é€Ÿåº¦ï¼šè·ç¦»è¶Šè¿œé€Ÿåº¦è¶Šå¿«
          let currentSpeed = minSpeed + (initialSpeed - minSpeed) * progress;
          
          if (curDist < minSpeed) {
            this.pos = this.targetPos.copy();
            this.angle = 0;
            this.done = true;
          } else {
            let dir = p5.Vector.sub(this.targetPos, this.pos);
            dir.normalize();
            this.pos.add(dir.mult(currentSpeed)); // ä½¿ç”¨è®¡ç®—å‡ºçš„å½“å‰é€Ÿåº¦
            this.angle = map(curDist, 0, this.initDist, 0, PI);
          }
        } else {
          this.angle = 0;
        }
      }
    }

    let totalKeyPresses = 0;      // æ€»æ•²å‡»æ¬¡æ•°
    let currentKeyPresses = 0;    // å½“å‰ä¼šè¯æ•²å‡»æ¬¡æ•°
    let messageCount = 0;         // å‘é€æ¶ˆæ¯æ•°
    let speedHistory = [];        // é€Ÿåº¦å†å²è®°å½•
    let typingStartTime = null;   // å½“å‰è¾“å…¥ä¼šè¯å¼€å§‹æ—¶é—´
    let lastTypingTime = null;    // æœ€åä¸€æ¬¡è¾“å…¥æ—¶é—´
    let typingTimeout = null;     // é‡ç½®è®¡æ—¶å™¨
    const MAX_SPEED = 10;         // æœ€å¤§é€Ÿåº¦ï¼ˆæ¬¡/ç§’ï¼‰
    const TYPING_INTERVAL = 2000; // é‡ç½®é—´éš”ï¼ˆæ¯«ç§’ï¼‰

    function aaa() {
      const now = Date.now();

      if (!typingStartTime || (now - lastTypingTime) > TYPING_INTERVAL) {
        typingStartTime = now;
        currentKeyPresses = 0;
      }

      lastTypingTime = now;
      currentKeyPresses++;
      totalKeyPresses++;

      if (typingTimeout) {
        clearTimeout(typingTimeout);
      }

      const timeElapsed = (now - typingStartTime) / 1000;
      if (timeElapsed > 0) {
        const pressesPerSecond = (currentKeyPresses / timeElapsed).toFixed(1);
        document.getElementById('replySpeed').textContent = pressesPerSecond;
        updateLaborStats(Number(pressesPerSecond));
      }

      typingTimeout = setTimeout(() => {
        typingStartTime = null;
        currentKeyPresses = 0;
        document.getElementById('replySpeed').textContent = '0.0';
        updateLaborStats(0);
      }, TYPING_INTERVAL);
    }

    // +++ New function to draw the face mesh +++
    function drawFaceMesh() {
      if (trackingConfig.doAcquireFaceLandmarks && faceLandmarks && faceLandmarks.faceLandmarks && faceLandmarks.faceLandmarks.length > 0) {
        const landmarks = faceLandmarks.faceLandmarks[0];
        
        push();
        stroke(255, 255, 255, 60); // Increased transparency
        strokeWeight(1);
        noFill();

        // Draw Tesselation lines (the main mesh)
        if (FaceLandmarker && FaceLandmarker.FACE_LANDMARKS_TESSELATION) {
          // for (const connection of FaceLandmarker.FACE_LANDMARKS_TESSELATION) { // REMOVE old loop
          // Draw only every Nth line to reduce density
          const connections = FaceLandmarker.FACE_LANDMARKS_TESSELATION;
          for (let i = 0; i < connections.length; i++) {
            if (i % 3 === 0) { // Only draw every 3rd line
              const connection = connections[i]; // Get the current connection
              const start = landmarks[connection.start];
              const end = landmarks[connection.end];
              if (start && end) { // Check if landmarks exist
                // --- USE CORRECT PROPORTIONAL MAPPING --- 
                // --- Shifted Left & Proportional Mapping --- 
                line(
                  map(start.x, 0, 1, width / 2, -width / 6), map(start.y, 0, 1, height / 6, 5 * height / 6), // Shift X left
                  map(end.x, 0, 1, width / 2, -width / 6),   map(end.y, 0, 1, height / 6, 5 * height / 6)    // Shift X left
                );
              }
            }
          }
        }
        
        // Optionally draw other features like lips, eyes etc. with different colors/weights if needed
        // Example: Draw Lips thicker
        /*
        stroke(255, 150, 150, 150); // Light red
        strokeWeight(2);
        if (FaceLandmarker && FaceLandmarker.FACE_LANDMARKS_LIPS) {
           for (const connection of FaceLandmarker.FACE_LANDMARKS_LIPS) {
            const start = landmarks[connection.start];
            const end = landmarks[connection.end];
             if (start && end) { 
               line(
                 map(start.x, 0, 1, width, 0), map(start.y, 0, 1, 0, height),
                 map(end.x, 0, 1, width, 0), map(end.y, 0, 1, 0, height)
               );
             }
           }
        }
        */

        pop();
      }
    }
    // +++ End new function +++

    // +++ New function to draw the data rain background +++
    function drawDataBackground() {
      // background(30, 30, 50, 100); // Semi-transparent dark background for the rain effect - REMOVED
      textFont('Manrope'); // <<<< Ensure Manrope for data rain
      fill(255, 200, 230, 100); // é™ä½ç¬¦å·ä¸é€æ˜åº¦åˆ°100
      textSize(symbolSize);
      for (let s of bgSymbols) {
        s.show();
        s.update();
      }
    }
    // +++ End new function +++

    // +++ Add CharSymbol Class Definition +++
    class CharSymbol {
      constructor(x, y) { // Simplify constructor
        this.x = x;
        this.y = y;
        this.speed = random(1, 4);
        this.isEmoji = false;
        this.reset(); // Always reset from charPool initially
      }

      reset() {
        let index = Math.floor(Math.random() * charPool.length);
        this.value = charPool[index];
      }

      update() {
        this.y += this.speed;
        if (this.y > height) {
          this.y = random(-100, 0);
          this.reset();
        }
      }

      show() {
        // Calculate alpha based on horizontal distance from center
        let baseColor = [255, 200, 230]; // Base soft pink color
        let maxAlpha = 30; // é™ä½æœ€å¤§é€æ˜åº¦ä»50åˆ°30
        let minAlpha = 8;  // é™ä½æœ€å°é€æ˜åº¦ä»10åˆ°8
        let distFromCenter = abs(this.x - width / 2);
        let calculatedAlpha = map(distFromCenter, 0, width / 2, maxAlpha, minAlpha);
        calculatedAlpha = constrain(calculatedAlpha, minAlpha, maxAlpha); // Ensure alpha stays within bounds

        // æ·»åŠ æ¨¡ç³Šæ•£ç‚¹æ•ˆæœ - ç»˜åˆ¶å¤šä¸ªåŠé€æ˜çš„ç‚¹
        push();
        textSize(symbolSize * 0.9); // ç¨å¾®å°ä¸€ç‚¹çš„æ–‡æœ¬å°ºå¯¸
        
        // ç»˜åˆ¶å¤šä¸ªåç§»ç‰ˆæœ¬çš„å­—ç¬¦æ¥åˆ›å»ºæ¨¡ç³Šæ•ˆæœ
        for (let i = 0; i < 3; i++) {
          let offsetX = random(-2, 2);
          let offsetY = random(-2, 2);
          let blurAlpha = calculatedAlpha * 0.3; // æ›´é€æ˜çš„å‰¯æœ¬
          
          fill(baseColor[0], baseColor[1], baseColor[2], blurAlpha);
          text(this.value, this.x + offsetX, this.y + offsetY);
        }
        
        // ç»˜åˆ¶ä¸»å­—ç¬¦
        textSize(symbolSize);
        fill(baseColor[0], baseColor[1], baseColor[2], calculatedAlpha * 0.8); // ä¸»å­—ç¬¦ä¹Ÿè¦ç¨å¾®é€æ˜ç‚¹
        text(this.value, this.x, this.y);
        pop();
      }
    }
    // +++ End CharSymbol Class Definition +++

    // +++ New function to update emoji positions periodically +++
    function updateEmojiPositions() {
      if (isHappy) {
        // Calculate necessary dimensions if needed (artTopLeftX, artWidth etc might need to be accessible or recalculated)
        // We need the drawing context dimensions here. Let's approximate based on capture size.
        // +++ Re-calculate dimensions here if needed, or ensure they are globally accessible +++
        let artTopLeftX = captureCenterPos.x - myCapture.width / 2 - 4;
        let artWidth = myCapture.width + 8;
        let artTopLeftY = captureCenterPos.y - myCapture.height / 2 - 4;
        let artHeight = myCapture.height + 8;

        // åœ¨åº•éƒ¨ç”Ÿæˆä¸€è¡Œemojiï¼Œä¸å†éšæœºä½ç½®
        let numEmojis = floor(random(1, 5)); // æ˜¾ç¤º1-4ä¸ªemoji
        
        // æ¸…é™¤ä¹‹å‰çš„emojiæ•°ç»„å¹¶ç”Ÿæˆæ–°çš„
        emojiPositions = [];
        
        // è®¡ç®—æ”¾ç½®ä½ç½®ï¼šåº•éƒ¨ä¸­å¤®ä¸€è¡Œ
        let totalWidth = numEmojis * cellSizeEmoji;
        let startX = artTopLeftX + (artWidth - totalWidth) / 2;
        let emojiY = artTopLeftY + artHeight - cellSizeEmoji / 2; // Adjust Y slightly for better centering
        
        for (let i = 0; i < numEmojis; i++) {
          // éšæœºé€‰æ‹©emojiï¼Œä½†ä½ç½®æ˜¯å›ºå®šçš„ä¸€è¡Œ
          let randomEmoji = happyEmojis[floor(random(happyEmojis.length))];
          let emojiX = startX + i * cellSizeEmoji + cellSizeEmoji / 2;
          
          // å­˜å‚¨emojiä¿¡æ¯
          emojiPositions.push({
            emoji: randomEmoji,
            x: emojiX, 
            y: emojiY
          });
        }
      } else {
        // If not happy, clear existing emojis
        emojiPositions = [];
      }
    }
    // +++ End new function +++

    // Helper function to play sound
    function playSound(soundId) {
        const sound = document.getElementById(soundId);
        if (sound) {
            sound.currentTime = 0; // Reset playback to start
            sound.play().catch(error => {
                console.error(`Error playing sound ${soundId}:`, error);
            });
        } else {
            console.error(`Sound element with id ${soundId} not found.`);
        }
    }

  </script>
</body>

</html>

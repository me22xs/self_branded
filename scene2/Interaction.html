<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <!-- 添加Manrope字体 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;600&display=swap" rel="stylesheet">
    <!-- 添加Cookie字体 -->
    <link href="https://fonts.googleapis.com/css2?family=Cookie&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.js"></script>
    <script src="glitchEffect.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            background: url('./assets/background8.webp');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            font-family: 'Manrope', sans-serif;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
           
            pointer-events: none;
            z-index: 1;
        }

        #navBar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 1002; /* 提高z-index，确保显示在其他元素上层 */
        }

        .nav-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .nav-right {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-left: auto; /* 将内容推到右侧 */
        }

        .timer {
            color: #fff;
            font-size: 18px;
            font-weight: 500;
            background: rgba(0, 0, 0, 0.4);
            padding: 6px 12px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 1002; /* 提高z-index，确保显示在其他元素上层 */
            position: relative; /* 添加相对定位以使z-index生效 */
        }

        .timer i {
            font-size: 16px;
            color: #4CAF50;
        }

        .timer span {
            color: #FFD700; /* 修改为软黄色 */
        }

 

        .next-comment-btn {
            background: #ffff00;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            color: #333;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            display: none;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .next-comment-btn:hover {
            background: rgba(255, 255, 255, 0.06);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            color: #fff;
        }

        .next-comment-btn i {
            font-size: 18px;
            color: #333;
        }

        .next-comment-btn:hover i {
            color: #fff;
        }

        .comment-count {
            color: #fff;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.4);
            padding: 4px 12px;
            border-radius: 12px;
            margin-left: 8px;
        }

        .nav-title {
            font-size: 24px;
            font-weight: 600;
            color: #333;
            display: none;
            /* 隐藏标题 */
        }

        .interaction-icons {
            display: flex;
            gap: 16px;
            margin-left: auto;
            /* 将图标推到右边 */
        }

        .interaction-icons i {
            font-size: 24px;
            color: #fff;
            cursor: pointer;
        }

        #commentBox {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 50%;
            max-width: 800px;
            min-width: 300px;
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            z-index: 1000;
            backdrop-filter: blur(12px);
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .comment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .next-comment-btn.show {
            display: flex;
            /* 显示时使用flex布局 */
        }

        .comment-count {
            color: #fff;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.4);
            padding: 4px 8px;
            border-radius: 12px;
            margin-left: 8px;
        }

        .username {
            color: #fff;
            font-weight: 600;
            font-size: 18px;
            margin-bottom: 4px;
        }

        .comment {
            color: #fff;
            font-size: 18px;
            line-height: 1.4;
            margin-bottom: 8px;
            padding: 10px;
            border-radius: 8px;
            background: none;
            border: none;
        }

        #inputArea {
            position: fixed;
            bottom: 0;
            right: 20px;
            width: 50%;
            max-width: 800px;
            min-width: 300px;
            padding: 16px;
            background: rgba(0, 0, 0, 0.8);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 12px;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(12px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            border-radius: 12px 12px 0 0;
        }

        #textInput {
            flex: 1;
            padding: 12px 16px;
            border: none;
            border-radius: 22px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 16px;
            outline: none;
        }

        #textInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        #sendButton {
            background: transparent;
            border: none;
            color: #fff;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            padding: 8px 16px;
        }

        #platformTip {
            position: fixed;
            bottom: 250px;
            right: 25%;
            transform: none;
            width: 50%;
            max-width: 180px;
            background: transparent;
            padding: 0;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .platform-tip {
            position: absolute;
            width: 100%;
            background: rgba(0,0,0,0.4);
            color: #ffdada;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            opacity: 1;
            transition: all 0.3s ease;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
        }

        canvas {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 150px;
            z-index: 2;
            mix-blend-mode: screen;
        }

        @keyframes keyPress {
            0% {
                color: #0095f6;
            }

            100% {
                color: #fff;
            }
        }

        .key-pressed {
            animation: keyPress 0.3s ease;
        }

        #taskInfo {
            position: fixed;
            top: 20px;
            right: calc(2% + 16% + 10px); /* 右边距 = laborStats右边距 + laborStats宽度 + 间距 */
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 12px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(12px);
            width: 18%;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #FFDADA;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            overflow: auto;
            min-width: 200px;
            max-width: 300px;
        }

        #laborStats {
            position: fixed;
            top: 20px;
            right: 2%;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 12px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(12px);
            width: 16%;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color:#FFDADA;
            min-width: 180px;
            max-width: 250px;
        }

        .task-title {
            color: #CCCCCC;
            font-size: 16px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .task-item {
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .task-item span {
            color: #FFD700; /* 修改为软黄色 */
        }

        .labor-title {
            font-weight: bold;
            color: #CCCCCC;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 16px;
        }

        .labor-title i {
            font-size: 18px;
            color: #F2F2F2;
        }

        .speed-meter {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin: 8px 0;
            position: relative;
            overflow: hidden;
        }

        .speed-bar {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(to right,#F2F2F2, rgba(255, 255, 255, 0.7));
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .speed-value {
            font-size: 24px;
            font-weight: 600;
            color: #F2F2F2;
            margin: 8px 0;
        }

        .speed-value span:first-child {
            color: #FFD700; /* 修改为软黄色 */
        }

        .speed-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            margin-top: 4px;
        }

        .labor-stats {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 14px;
            color: #ffdada;
        }

        .labor-stats span {
            color: #FFD700; /* 修改为软黄色 */
            font-weight: 600;
        }

        @keyframes float {
            0% {
                transform: translateX(-50%) translateY(0px);
            }

            50% {
                transform: translateX(-50%) translateY(-10px);
            }

            100% {
                transform: translateX(-50%) translateY(0px);
            }
        }

        /* 添加加载遮罩层样式 */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .loading-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .loading-text {
            color: #ffdada;
            font-size: 24px;
            font-weight: 500;
            animation: loadingPulse 1.5s infinite;
        }

        @keyframes loadingPulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }

        .emotion-analysis {
            position: fixed;
            right: 2%;
            top: calc(20px + 200px + 10px);
            background: rgba(0, 0, 0, 0.4);
            color: #ffdada;
            padding: 12px 20px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-around;
            gap: 10px;
            width: calc(9% + 18% + 16% + 10px); /* 匹配taskInfo + laborStats + 间距 */
            font-size: 14px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            height: 45px;
            box-sizing: border-box;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            min-width: 380px;
            max-width: 900px;
            z-index: 1001;
        }

        .emotion-analysis.show {
            opacity: 1;
            pointer-events: auto;
        }

        .emotion-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .emotion-label {
            color: #ffdada;
            font-size: 14px;
            min-width: 50px;
        }

        .emotion-label span:first-child {
            color: #ffdada;
        }

        .emotion-label span:last-child {
            color: #FFD700; /* 修改为软黄色 */
        }

        /* 添加标题栏样式 */
        .story-title-header {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #fff;
            z-index: 1004; /* 确保在所有元素上方 */
        }

        .title-text {
            font-family: 'Cookie', cursive;
            font-size: 32px;
            padding: 0px 20px;
            background: #2E3A67;
            border-radius: 10px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #FFDADA;
        }

        /* 添加居中Continue按钮的样式 */
        .center-continue-button {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            color: white;
            border: none;
            padding: 15px 50px;
            border-radius: 25px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            z-index: 2000;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
            display: none;
            font-family: 'Manrope', sans-serif;
            transition: all 0.3s ease;
        }

        .center-continue-button:hover {
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
        }
    </style>
</head>

<body>
    <div class="story-title-header">
        <div class="title-text">Scene2: Replying</div>
    </div>
    
    <button id="centerContinueButton" class="center-continue-button">Reflection</button>

    <div id="navBar">
        <div class="nav-right">
            <div class="timer">
                <i class="ri-time-line"></i>
                <span id="timerDisplay">00:00</span>
            </div>
        </div>
    </div>

    <div id="platformTip"></div>

    <div id="commentBox">
        <div class="comment-header">
            <div class="username"></div>
            <button class="next-comment-btn">
                <i class="ri-arrow-right-line"></i>
                Next comment · <span id="remainingComments">4</span> left
            </button>
        </div>
        <div class="comment"></div>
    </div>

    <div id="inputArea">
        <input type="text" id="textInput" placeholder="Replying...">
        <button id="sendButton">Send</button>
    </div>

    <div id="taskInfo">
        <div class="task-title">How to Use This Page</div>
        <div class="task-item"></div>
        <div class="task-item"><br>Reply to 5 comments to keep your personal brand active.<br>Press Enter or click Send <span style="color: #FFD700;">once</span> to submit each reply.</div>
        <div class="task-item" style="margin-top: 10px; color: #FFD700; font-style: italic;">* Requires internet connection</div>
    </div>

    <div id="laborStats">
        <div class="labor-title">
            <i class="ri-keyboard-line"></i>  Interaction Metrics
        </div>
        <div class="speed-value">
            <span id="replySpeed">0.0</span>
            <span class="speed-label"> keystrokes/sec</span>
        </div>
        <div class="speed-meter">
            <div class="speed-bar" id="speedBar"></div>
        </div>
        <div class="labor-stats">
            Typing Speed: <span id="averageSpeed">0.0</span>  keystrokes/sec
            <br>
            Total Keystrokes: <span id="totalInputCount">0</span> keystrokes
            <br>
            Avg/Reply: <span id="averageKeyCount">0</span> keystrokes
          
            
        </div>
    </div>

    <!-- 添加加载遮罩层 -->
    <div class="loading-overlay">
        <div class="loading-text">Loading...</div>
    </div>

    <div class="emotion-analysis">
        <div class="emotion-item">
            <div class="emotion-label">
                <span>Positive</span>
                <span id="positivePercentage">0%</span>
            </div>
        </div>
        <div class="emotion-item">
            <div class="emotion-label">
                <span>Neutral</span>
                <span id="neutralPercentage">0%</span>
            </div>
        </div>
        <div class="emotion-item">
            <div class="emotion-label">
                <span>Negative</span>
                <span id="negativePercentage">0%</span>
            </div>
        </div>
    </div>

    <script>
        let floatingGroups = [];
        let currentCommentIndex = 0;
        let nextStopY = 100;
        let totalComments = 5;
        let hasReplied = false;
        let glitchEffect = null;

        // 将API密钥定义为常量
        const OPENAI_API_KEY = "YOUR_API_KEY_HERE"; // ✅ 安全做法
        
        // 键盘输入相关变量
        let totalKeyPresses = 0;      // 总敲击次数
        let currentKeyPresses = 0;    // 当前会话敲击次数
        let messageCount = 0;         // 发送消息数
        let speedHistory = [];        // 速度历史记录
        let typingStartTime = null;   // 当前输入会话开始时间
        let lastTypingTime = null;    // 最后一次输入时间
        let typingTimeout = null;     // 重置计时器
        const MAX_SPEED = 10;         // 最大速度（次/秒）
        const TYPING_INTERVAL = 2000; // 重置间隔（毫秒）

        const platformTips = [
            "✨ Your interaction rate is increasing",
            "❤️ Your reply received a like ",
            " You're gaining new followers! "
        ];

        const popularEmojis = [
            '✨', '🤍', '🎀', '🫶', '💗',
            '🌸', '🫧', '🧸', '💕', '💪',
        ];

        class CommentFloater {
            constructor(username, text) {
                this.username = username;
                this.text = text;
                const commentBox = document.getElementById('commentBox');
                const rect = commentBox.getBoundingClientRect();
                this.x = windowWidth / 2;
                this.y = rect.top - 100;
                this.targetY = nextStopY;
                this.speed = random(2, 4);
                this.opacity = 255;
                this.arrived = false;
                this.characters = [];
                // 使用 Array.from 来正确处理多字节字符（如Emoji）
                const textChars = Array.from(text);
                this.totalLength = textChars.length; // 正确的总长度

                // 创建用户名漂浮字符 (保持不变)
                for (let i = 0; i < username.length; i++) {
                    this.characters.push(new FloatingCharacter(
                        username[i],
                        i,
                        username.length, 
                        this.targetY,
                        false
                    ));
                }

                // 创建评论内容（包括Emoji）的漂浮字符
                let charIndex = 0;
                for (const char of textChars) {
                    this.characters.push(new FloatingCharacter(
                        char,           // 当前字符或Emoji
                        charIndex,      // 字符在处理后数组中的索引
                        this.totalLength, // 使用新的总长度
                        this.targetY + 20,
                        false // isEmoji 标志可能不再需要，或者需要更智能的判断
                    ));
                    charIndex++;
                }
                
                // 移除之前添加随机 popularEmojis 的代码
                // this.emoji = getRandomEmoji(); 
                // this.characters.push(new FloatingCharacter(...
            }

            move() {
                if (!this.arrived) {
                    if (this.y > this.targetY) {
                        this.y -= this.speed;
                    } else {
                        this.arrived = true;
                        this.y = this.targetY;
                    }
                }
                // 移动所有字符
                for (let char of this.characters) {
                    char.move();
                }
            }

            display() {
                // 显示所有字符
                for (let char of this.characters) {
                    char.display();
                }
            }

            isComplete() {
                return this.arrived && this.characters.every(char => char.arrived);
            }
        }

        let floatingComments = [];
        let currentComment = { username: "@mochi.gif", text: "This energy is everything 💗" };
        const comments = [
            {
                username: "@mochi.gif",
                text: "This energy is everything 💗"
            },
            {
                username: "@her.glow.journey",
                text: "Wow this feels so real and raw!! thank you for sharing"
            },
            {
                username: "@_.stella.x_",
                text: "Omg. You make that yoga pose loook SO easy 😢 haha body goals"
            },
            {
                username: "@softlyunhinged",
                text: "pls make more like this I'm OBSESSED"
            },
            {
                username: "@yanis_dude7",
                text: "Jwww how tall are you?"
            }
        ];

        // 添加情绪分析相关变量
        let emotionStats = {
            positive: 0,
            neutral: 0,
            negative: 0,
            total: 0
        };
        
        let emotionHistory = [];
        
        // 初始化时清除之前的数据
        function initEmotionStats() {
            // 清除 localStorage 中的数据
            localStorage.removeItem('emotionStats');
            localStorage.removeItem('emotionHistory');
            
            // 重置统计变量
            emotionStats = {
                positive: 0,
                neutral: 0,
                negative: 0,
                total: 0
            };
            emotionHistory = [];
        }
        
        // 在页面加载时初始化
        initEmotionStats();
        
        // 添加情绪分析函数
        async function analyzeEmotion(text) {
            try {
                console.log('Analyzing text:', text);
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: "gpt-3.5-turbo",
                        messages: [{
                            role: "system",
                            content: 'Analyze the emotional tone of the following reply and return only one of these three labels: "positive", "neutral", or "negative". Do not return any other text.'
                        }, {
                            role: "user",
                            content: text
                        }],
                        temperature: 0.3
                    })
                });

                const data = await response.json();
                console.log('API Response:', data);
                const emotion = data.choices[0].message.content.trim().toLowerCase();
                console.log('Analyzed emotion:', emotion);
                return emotion;
            } catch (error) {
                console.error('Error analyzing emotion:', error);
                return 'neutral';
            }
        }

        // 更新情绪统计
        function updateEmotionStats(emotion) {
            console.log('Updating stats with emotion:', emotion);
            // 确保 emotion 是有效的值
            if (['positive', 'neutral', 'negative'].includes(emotion)) {
                emotionStats[emotion]++;
                emotionStats.total++;
                emotionHistory.push(emotion);
                
                // 计算百分比
                const positivePercent = ((emotionStats.positive / emotionStats.total) * 100).toFixed(1);
                const neutralPercent = ((emotionStats.neutral / emotionStats.total) * 100).toFixed(1);
                const negativePercent = ((emotionStats.negative / emotionStats.total) * 100).toFixed(1);
                
                console.log('Updated stats:', emotionStats);
                console.log('Percentages:', {positivePercent, neutralPercent, negativePercent});
                
                // 存储统计数据
                localStorage.setItem('emotionStats', JSON.stringify(emotionStats));
                localStorage.setItem('emotionHistory', JSON.stringify(emotionHistory));
                
                // 显示情绪分析结果
                showEmotionAnalysis(positivePercent, neutralPercent, negativePercent);
                
                return {
                    positive: positivePercent,
                    neutral: neutralPercent,
                    negative: negativePercent
                };
            }
            console.log('Invalid emotion value:', emotion);
            return {
                positive: '0.0',
                neutral: '0.0',
                negative: '0.0'
            };
        }

        // 显示情绪分析结果
        function showEmotionAnalysis(positive, neutral, negative) {
            const analysisElement = document.querySelector('.emotion-analysis');
            const positiveElement = document.getElementById('positivePercentage');
            const neutralElement = document.getElementById('neutralPercentage');
            const negativeElement = document.getElementById('negativePercentage');
            
            // 更新百分比显示
            positiveElement.textContent = `${positive}%`;
            neutralElement.textContent = `${neutral}%`;
            negativeElement.textContent = `${negative}%`;
            
            // 显示分析结果
            analysisElement.classList.add('show');
            
            /* 
            // 显示容器尺寸
            showContainerSize(analysisElement, 'emotion-analysis');
            */
            
            // 3秒后自动隐藏
            setTimeout(() => {
                analysisElement.classList.remove('show');
                
                /* 
                // 移除尺寸显示
                const sizeDisplay = analysisElement.querySelector('.size-display');
                if (sizeDisplay) {
                    sizeDisplay.remove();
                }
                */
            }, 3000);
        }

        function updateLaborStats(speed) {
            // 更新速度条
            const percentage = Math.min((speed / MAX_SPEED) * 100, 100);
            document.getElementById('speedBar').style.width = `${percentage}%`;

            // 更新总计敲击次数
            document.getElementById('totalInputCount').textContent = totalKeyPresses;

            // 更新平均每条敲击
            document.getElementById('averageKeyCount').textContent =
                messageCount > 0 ? Math.round(totalKeyPresses / messageCount) : 0;

            // 更新平均速度
            if (speed > 0) {
                speedHistory.push(speed);
                const avgSpeed = (speedHistory.reduce((a, b) => a + b, 0) / speedHistory.length).toFixed(1);
                document.getElementById('averageSpeed').textContent = avgSpeed;
            }
        }

        class FloatingCharacter {
            constructor(char, index, totalChars, targetY, isEmoji = false) {
                this.char = char;
                this.isEmoji = isEmoji;
                this.x = windowWidth * 0.3 + (index - totalChars / 2) * 12.5;
                const inputArea = document.getElementById('inputArea');
                const rect = inputArea.getBoundingClientRect();
                this.y = rect.top - 100;
                this.targetY = targetY;
                this.speed = random(2, 4);
                this.opacity = 255;
                this.wiggle = random(0, TWO_PI);
                this.wiggleSpeed = random(0.01, 0.02);
                this.arrived = false;
                
                // 添加颜色相关属性
                this.colorPhase = random(0, TWO_PI);  // 随机初始相位
                this.colorSpeed = random(0.01, 0.03); // 随机颜色变化速度
            }

            move() {
                if (!this.arrived) {
                    if (this.y > this.targetY) {
                        this.y -= this.speed;
                    } else {
                        this.arrived = true;
                        this.y = this.targetY;
                    }
                } else {
                    this.wiggle += this.wiggleSpeed;
                    this.x += sin(this.wiggle) * 0.4;
                    
                    // 更新颜色相位
                    this.colorPhase += this.colorSpeed;
                }
            }

            getColor() {
                // Instagram配色方案
                const instagramColors = [
                    color(131, 58, 180),  // #833AB4 紫色
                    color(225, 48, 108),  // #E1306C 粉色
                    color(252, 175, 69)   // #FCAF45 黄色
                ];
                
                // 使用正弦函数在三个颜色之间平滑过渡
                const phase = this.colorPhase % TWO_PI;
                const colorIndex = floor(phase / (TWO_PI / 3));
                const nextColorIndex = (colorIndex + 1) % 3;
                const progress = (phase % (TWO_PI / 3)) / (TWO_PI / 3);
                
                // 在两个颜色之间插值
                const currentColor = instagramColors[colorIndex];
                const nextColor = instagramColors[nextColorIndex];
                
                const r = lerp(red(currentColor), red(nextColor), progress);
                const g = lerp(green(currentColor), green(nextColor), progress);
                const b = lerp(blue(currentColor), blue(nextColor), progress);
                
                return color(r, g, b, this.opacity);
            }

            display() {
                push();
                textAlign(CENTER);
                textSize(16);  // 固定大小16
                fill(this.getColor());
                text(this.char, this.x, this.y);
                pop();
            }
        }

        function showPlatformTip(message) {
            const tipElement = document.getElementById('platformTip');
            const newTip = document.createElement('div');
            newTip.className = 'platform-tip';
            newTip.textContent = message || platformTips[Math.floor(Math.random() * platformTips.length)];
            
            // 将所有现有提示上移
            const existingTips = tipElement.querySelectorAll('.platform-tip');
            existingTips.forEach(tip => {
                const currentBottom = parseInt(tip.style.bottom || '0');
                tip.style.bottom = (currentBottom + 55) + 'px';  // 固定间距为 55px (45px高度 + 10px间距)
            });
            
            // 添加新提示
            newTip.style.bottom = '0px';
            tipElement.appendChild(newTip);
            tipElement.style.opacity = '1';
        }

        function createFloatingText(text) {
            let newGroup = [];
            // 使用 Array.from 来正确处理可能包含多字节字符的输入文本
            const textChars = Array.from(text);
            const totalLength = textChars.length; // 总长度现在就是文本本身的长度

            let charIndex = 0;
            for (const char of textChars) {
                newGroup.push(new FloatingCharacter(
                    char, 
                    charIndex, 
                    totalLength, 
                    nextStopY // 使用相同的nextStopY
                )); 
                charIndex++;
            }
            
            floatingGroups.push(newGroup);
        }

        function getRandomEmoji() {
            return popularEmojis[Math.floor(Math.random() * popularEmojis.length)];
        }

        function showNextComment() {
            if (currentCommentIndex >= comments.length) return;

            currentComment = comments[currentCommentIndex];
            document.querySelector('.username').textContent = currentComment.username;
            document.querySelector('.comment').innerHTML = currentComment.text;
        }

        let startTime = null;
        let timerInterval = null;
        let isTimerRunning = false;

        // 格式化时间
        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // 更新计时器显示
        function updateTimer() {
            if (startTime) {
                const elapsed = Date.now() - startTime;
                document.getElementById('timerDisplay').textContent = formatTime(elapsed);
            }
        }

        // 开始计时
        function startTimer() {
            if (!isTimerRunning) {
                startTime = Date.now();
                isTimerRunning = true;
                timerInterval = setInterval(updateTimer, 1000);
            }
        }

        // 停止计时
        function stopTimer() {
            if (isTimerRunning) {
                clearInterval(timerInterval);
                isTimerRunning = false;
                // 保存总时间和总敲击次数
                const totalTime = Math.floor((Date.now() - startTime) / 1000);
                localStorage.setItem('totalTime', totalTime.toString());
                localStorage.setItem('totalKeyPresses', totalKeyPresses.toString());
            }
        }

        // 添加输入合法性检测函数
        async function validateInput(text) {
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: "gpt-3.5-turbo",
                        messages: [{
                            role: "system",
                            content: 'Determine if the input is a valid reply. Return only "valid" or "invalid". Criteria:\n- valid: any meaningful combination of words used in daily life, including simple interjections, emojis, or internet slang\n- invalid: obvious keyboard mashing (e.g., "asdfgh", "123456", ".,./;\'[]") or random character combinations'
                        }, {
                            role: "user",
                            content: text
                        }],
                        temperature: 0.3
                    })
                });

                const data = await response.json();
                return data.choices[0].message.content.trim().toLowerCase() === 'valid';
            } catch (error) {
                console.error('Error validating input:', error);
                return true;
            }
        }

        // 修改键盘输入事件监听
        document.getElementById('textInput').addEventListener('keydown', function(e) {
            if (typeSound && typeSound.isLoaded()) {
                typeSound.play();
            }
            // 处理回车键
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (hasReplied) {
                    showPlatformTip("Click next to continue replying.");
                    return;
                }
                document.getElementById('sendButton').click();
                return;
            }

            startTimer(); // 开始计时
            
            // 创建故障效果
            if (glitchEffect) {
                glitchEffect.createGlitch();
            }
            
            const now = Date.now();
            
            // 如果超过2秒没有输入，重置当前会话
            if (!typingStartTime || (now - lastTypingTime) > TYPING_INTERVAL) {
                typingStartTime = now;
                currentKeyPresses = 0;
            }
            
            lastTypingTime = now;
            currentKeyPresses++;
            totalKeyPresses++;
            
            // 清除之前的超时
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }
            
            // 计算当前输入速度
            const timeElapsed = (now - typingStartTime) / 1000;
            if (timeElapsed > 0) {
                const pressesPerSecond = (currentKeyPresses / timeElapsed).toFixed(1);
                document.getElementById('replySpeed').textContent = pressesPerSecond;
                updateLaborStats(Number(pressesPerSecond));
            }
            
            // 设置2秒后重置当前会话
            typingTimeout = setTimeout(() => {
                typingStartTime = null;
                currentKeyPresses = 0;
                document.getElementById('replySpeed').textContent = '0.0';
                updateLaborStats(0);
            }, TYPING_INTERVAL);
        });

        // 发送按钮事件
        document.getElementById('sendButton').addEventListener('click', async () => {
            const text = document.getElementById('textInput').value.trim();
            if (text) {
                // 触发故障效果
                if (glitchEffect) {
                    glitchEffect.createGlitch();
                }

                if (hasReplied) {
                    showPlatformTip("Click next to continue replying.");
                    return;
                }

                // 先验证输入
                const isValid = await validateInput(text);
                if (!isValid) {
                    showPlatformTip("Please enter a meaningful reply.");
                    return;
                }

                // 分析情绪但不显示
                const emotion = await analyzeEmotion(text);
                updateEmotionStats(emotion);

                // 显示随机平台提示
                const randomTip = platformTips[Math.floor(Math.random() * platformTips.length)];
                showPlatformTip(randomTip);

                hasReplied = true;
                createFloatingText(text);

                // 清空评论区
                document.querySelector('.username').textContent = '';
                document.querySelector('.comment').textContent = '';

                // 检查是否是最后一条评论
                if (currentCommentIndex === totalComments - 1) {
                    // 如果是最后一条评论，隐藏Next comment按钮，延迟后显示中央Continue按钮
                    document.querySelector('.next-comment-btn').style.display = 'none';
                    setTimeout(() => {
                        document.getElementById('centerContinueButton').style.display = 'block';
                    }, 2000); // 2秒后显示Continue按钮
                } else {
                    // 显示下一条评论按钮
                    document.querySelector('.next-comment-btn').classList.add('show');
                }

                setTimeout(() => {
                    const floatingComment = new CommentFloater(currentComment.username, currentComment.text);
                    floatingComments.push(floatingComment);
                    nextStopY += 80;
                }, 1500);

                document.getElementById('textInput').value = '';
                messageCount++;
                
                // 更新统计显示
                document.getElementById('totalInputCount').textContent = totalKeyPresses;
                document.getElementById('averageKeyCount').textContent = 
                    messageCount > 0 ? Math.round(totalKeyPresses / messageCount) : 0;
                if (speedHistory.length > 0) {
                    const avgSpeed = (speedHistory.reduce((a, b) => a + b, 0) / speedHistory.length).toFixed(1);
                    document.getElementById('averageSpeed').textContent = avgSpeed;
                }
                
                // 重置当前会话的统计
                currentKeyPresses = 0;
                typingStartTime = null;
                lastTypingTime = null;
                document.getElementById('replySpeed').textContent = '0.0';
                document.getElementById('speedBar').style.width = '0%';
            }
        });

        // 下一条评论按钮事件
        document.querySelector('.next-comment-btn').addEventListener('click', () => {
            // 触发故障效果
            if (glitchEffect) {
                glitchEffect.createGlitch();
            }

            if (!hasReplied) {
                showPlatformTip("Please reply to the current comment first.");
                return;
            }

            if (currentCommentIndex < totalComments - 1) {
                currentCommentIndex++;
                hasReplied = false;
                showNextComment();
                updateRemainingCount();
                // 隐藏下一条评论按钮
                document.querySelector('.next-comment-btn').classList.remove('show');
            } else {
                // 所有评论已回复，显示中央Continue按钮
                document.querySelector('.next-comment-btn').style.display = 'none';
                document.getElementById('centerContinueButton').style.display = 'block';
            }
        });

        // 中央Continue按钮事件
        document.getElementById('centerContinueButton').addEventListener('click', () => {
            stopTimer(); // 停止计时
            // 直接跳转到scene2_reflection.html，不显示加载遮罩层
            window.location.href = 'scene2_reflection.html';
        });

        function updateRemainingCount() {
            const remaining = totalComments - currentCommentIndex - 1;
            document.getElementById('remainingComments').textContent = remaining;

            // 更新按钮文字
            const button = document.querySelector('.next-comment-btn');
            if (remaining === 0) {
                button.innerHTML = '<i class="ri-arrow-right-line"></i>Next comment';
            } else {
                button.innerHTML = '<i class="ri-arrow-right-line"></i>Next comment · <span id="remainingComments">' + remaining + '</span> left';
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight - 210);
        }

        let typeSound;

        function preload() {
            typeSound = loadSound('./assets/type.mp3');
        }

        function setup() {
            let canvas = createCanvas(windowWidth, windowHeight - 210);
            canvas.position(0, 50);
            canvas.style('z-index', '999');
            textFont('monospace');
            background(0, 0, 0, 0);
            
            // 初始化故障效果
            glitchEffect = new GlitchEffect();
            
            // 添加点击事件监听器
            document.body.addEventListener('click', function(e) {
                // 排除输入框和按钮的点击
                if (!e.target.closest('#inputArea') && !e.target.closest('.next-comment-btn')) {
                    glitchEffect.createGlitch();
                }
            });
        }

        // 添加DOMContentLoaded事件监听器
        document.addEventListener('DOMContentLoaded', function() {
            showNextComment();
            updateRemainingCount();
            
            // 调整任务信息高度与劳动统计容器一致
            const laborStats = document.getElementById('laborStats');
            const taskInfo = document.getElementById('taskInfo');
            const emotionAnalysis = document.querySelector('.emotion-analysis');
            
            if (laborStats && taskInfo && emotionAnalysis) {
                // 使用 getComputedStyle 获取实际样式
                const laborStyle = window.getComputedStyle(laborStats);
                const taskStyle = window.getComputedStyle(taskInfo);
                
                // 设置任务信息容器的内容高度
                taskInfo.style.height = laborStats.offsetHeight + 'px';
                
                // 确保元素不重叠
                adjustContainersLayout();
                
                // 调整任务信息内部容器的样式
                const taskTitle = taskInfo.querySelector('.task-title');
                if (taskTitle) {
                    taskTitle.style.marginBottom = '10px';
                }
                
                // 在生产环境中禁用尺寸显示
                /* 
                // 显示容器尺寸
                showContainerSize(laborStats, 'laborStats');
                showContainerSize(taskInfo, 'taskInfo');
                showContainerSize(emotionAnalysis, 'emotion-analysis');
                */
                
                // 添加窗口大小变化的处理
                window.addEventListener('resize', function() {
                    // 重新调整任务信息容器高度
                    taskInfo.style.height = laborStats.offsetHeight + 'px';
                    
                    // 确保元素不重叠
                    adjustContainersLayout();
                    
                    /* 
                    // 更新尺寸显示
                    updateSizeDisplay(laborStats);
                    updateSizeDisplay(taskInfo);
                    updateSizeDisplay(emotionAnalysis);
                    */
                });
            }
        });

        // 调整容器布局确保不重叠
        function adjustContainersLayout() {
            const laborStats = document.getElementById('laborStats');
            const taskInfo = document.getElementById('taskInfo');
            const emotionAnalysis = document.querySelector('.emotion-analysis');
            
            if (!laborStats || !taskInfo || !emotionAnalysis) return;
            
            // 获取实际宽度和位置
            const laborRect = laborStats.getBoundingClientRect();
            const taskRect = taskInfo.getBoundingClientRect();
            const windowWidth = window.innerWidth;
            
            // 确保laborStats保持在最右侧
            laborStats.style.right = '2%';
            
            // 根据laborStats的实际位置和宽度动态设置taskInfo的位置
            const laborRight = laborRect.right;
            const laborLeft = laborRect.left;
            const laborWidth = laborRect.width;
            
            // 计算taskInfo应该在的位置，确保两者之间有10px间距
            const taskRight = laborLeft - 10;
            const rightPercentage = ((windowWidth - taskRight) / windowWidth) * 100;
            
            // 设置taskInfo的right位置
            taskInfo.style.right = `${rightPercentage}%`;
            
            // 获取调整后的位置和尺寸
            const updatedTaskRect = taskInfo.getBoundingClientRect();
            const updatedLaborRect = laborStats.getBoundingClientRect();
            
            // 精确计算两个容器的总宽度加上间距
            const totalWidth = laborWidth + updatedTaskRect.width + (laborLeft - updatedTaskRect.right);
            
            // 更新情绪分析容器宽度
            emotionAnalysis.style.right = '2%';
            
            // 确保宽度在最小和最大值之间
            const minWidth = 380;
            const maxWidth = 900;
            
            if (totalWidth < minWidth) {
                emotionAnalysis.style.width = `${minWidth}px`;
            } else if (totalWidth > maxWidth) {
                emotionAnalysis.style.width = `${maxWidth}px`;
            } else {
                emotionAnalysis.style.width = `${totalWidth}px`;
            }
        }

        // 创建显示容器尺寸的函数
        function showContainerSize(container, name) {
            if (!container) return;
            
            // 获取容器的实际尺寸
            const rect = container.getBoundingClientRect();
            const width = Math.round(rect.width);
            const height = Math.round(rect.height);
            
            // 创建尺寸显示元素
            const sizeDisplay = document.createElement('div');
            sizeDisplay.className = 'size-display';
            sizeDisplay.textContent = `${width}×${height}`;
            sizeDisplay.style.position = 'absolute';
            sizeDisplay.style.top = '2px';
            sizeDisplay.style.right = '2px';
            sizeDisplay.style.fontSize = '10px';
            sizeDisplay.style.background = 'rgba(0,0,0,0.5)';
            sizeDisplay.style.color = '#ffff00';
            sizeDisplay.style.padding = '2px 4px';
            sizeDisplay.style.borderRadius = '3px';
            sizeDisplay.style.zIndex = '1001';
            
            // 确保容器是相对定位，以便绝对定位尺寸显示
            const originalPosition = window.getComputedStyle(container).position;
            if (originalPosition === 'static') {
                container.style.position = 'relative';
            }
            
            // 添加尺寸显示到容器
            container.appendChild(sizeDisplay);
            
            // 将尺寸信息输出到控制台
            console.log(`${name} 尺寸: ${width}×${height}px`);
        }

        // 更新尺寸显示
        function updateSizeDisplay(container) {
            if (!container) return;
            
            // 获取容器的实际尺寸
            const rect = container.getBoundingClientRect();
            const width = Math.round(rect.width);
            const height = Math.round(rect.height);
            
            // 查找并更新尺寸显示元素
            let sizeDisplay = container.querySelector('.size-display');
            if (sizeDisplay) {
                sizeDisplay.textContent = `${width}×${height}`;
            } else {
                // 如果没有则创建
                showContainerSize(container, container.id || 'container');
            }
        }

        function draw() {
            clear();
            background(0, 0, 0, 0); // 保持透明背景

            // 更新和显示故障效果
            glitchEffect.update();

            // 绘制漂浮文字
            for (let group of floatingGroups) {
                for (let char of group) {
                    char.move();
                    char.display();
                }
            }

            // 绘制漂浮的评论
            for (let comment of floatingComments) {
                comment.move();
                comment.display();
            }
        }

        // 确保页面加载和窗口大小变化时都立即调整布局
        window.addEventListener('load', function() {
            setTimeout(adjustContainersLayout, 0);
            
            // 移除所有已存在的尺寸显示
            document.querySelectorAll('.size-display').forEach(display => {
                display.remove();
            });
        });

        window.addEventListener('resize', function() {
            adjustContainersLayout();
        });
    </script>
</body>

</html>